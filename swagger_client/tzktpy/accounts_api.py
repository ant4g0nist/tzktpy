# coding: utf-8

"""
    TzKT API

    # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Hangzhounet: `https://api.hangzhounet.tzkt.io/` ([view docs](https://api.hangzhounet.tzkt.io)) - Ithacanet: `https://api.ithacanet.tzkt.io/` ([view docs](https://api.ithacanet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you must mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** or **\"Built with TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---   # noqa: E501

    OpenAPI spec version: v1.8.3
    Contact: hello@baking-bad.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AccountsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accounts_get(self, **kwargs):  # noqa: E501
        """Get accounts  # noqa: E501

        Returns a list of accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Type type: Filters accounts by type (`user`, `delegate`, `contract`, `ghost`).
        :param Kind kind: Filters accounts by contract kind (`delegator_contract` or `smart_contract`)
        :param Delegate delegate: Filters accounts by delegate. Allowed fields for `.eqx` mode: none.
        :param Balance balance: Filters accounts by balance
        :param Staked staked: Filters accounts by participation in staking
        :param LastActivity last_activity: Filters accounts by last activity level (where the account was updated)
        :param Select select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort sort: Sorts delegators by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`, `numContracts`.
        :param Offset offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get accounts  # noqa: E501

        Returns a list of accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Type type: Filters accounts by type (`user`, `delegate`, `contract`, `ghost`).
        :param Kind kind: Filters accounts by contract kind (`delegator_contract` or `smart_contract`)
        :param Delegate delegate: Filters accounts by delegate. Allowed fields for `.eqx` mode: none.
        :param Balance balance: Filters accounts by balance
        :param Staked staked: Filters accounts by participation in staking
        :param LastActivity last_activity: Filters accounts by last activity level (where the account was updated)
        :param Select select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort sort: Sorts delegators by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`, `numContracts`.
        :param Offset offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[Account]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'kind', 'delegate', 'balance', 'staked', 'last_activity', 'select', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'balance' in params:
            query_params.append(('balance', params['balance']))  # noqa: E501
        if 'staked' in params:
            query_params.append(('staked', params['staked']))  # noqa: E501
        if 'last_activity' in params:
            query_params.append(('lastActivity', params['last_activity']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        print(query_params)
        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        return self.api_client.call_api(
            '/v1/accounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Account]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_balance(self, address, **kwargs):  # noqa: E501
        """Get balance  # noqa: E501

        Returns account balance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_balance_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_balance_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_balance_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get balance  # noqa: E501

        Returns account balance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_balance_at_date(self, address, _datetime, **kwargs):  # noqa: E501
        """Get balance at date  # noqa: E501

        Returns account balance at the specified datetime  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_at_date(address, _datetime, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param datetime _datetime: Datetime at which you want to know account balance (e.g. `2020-01-01`, or `2019-12-30T23:42:59Z`) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_balance_at_date_with_http_info(address, _datetime, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_balance_at_date_with_http_info(address, _datetime, **kwargs)  # noqa: E501
            return data

    def accounts_get_balance_at_date_with_http_info(self, address, _datetime, **kwargs):  # noqa: E501
        """Get balance at date  # noqa: E501

        Returns account balance at the specified datetime  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_at_date_with_http_info(address, _datetime, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param datetime _datetime: Datetime at which you want to know account balance (e.g. `2020-01-01`, or `2019-12-30T23:42:59Z`) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', '_datetime']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_balance_at_date" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_balance_at_date`")  # noqa: E501
        # verify the required parameter '_datetime' is set
        if ('_datetime' not in params or
                params['_datetime'] is None):
            raise ValueError("Missing the required parameter `_datetime` when calling `accounts_get_balance_at_date`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if '_datetime' in params:
            path_params['datetime'] = params['_datetime']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/balance_history/{datetime}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_balance_at_level(self, address, level, **kwargs):  # noqa: E501
        """Get balance at level  # noqa: E501

        Returns account balance at the specified block  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_at_level(address, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param int level: Block height at which you want to know account balance (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_balance_at_level_with_http_info(address, level, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_balance_at_level_with_http_info(address, level, **kwargs)  # noqa: E501
            return data

    def accounts_get_balance_at_level_with_http_info(self, address, level, **kwargs):  # noqa: E501
        """Get balance at level  # noqa: E501

        Returns account balance at the specified block  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_at_level_with_http_info(address, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param int level: Block height at which you want to know account balance (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_balance_at_level" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_balance_at_level`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `accounts_get_balance_at_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'level' in params:
            path_params['level'] = params['level']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/balance_history/{level}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_balance_history(self, address, **kwargs):  # noqa: E501
        """Get balance history  # noqa: E501

        Returns time series with historical balances (only changes, without duplicates).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_history(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param int step: Step of the time series, for example if `step = 1000` you will get balances at blocks `1000, 2000, 3000, ...`.
        :param Select1 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort4 sort: Sorts historical balances by specified field. Supported fields: `level`.
        :param int offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote1 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[HistoricalBalance]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_balance_history_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_balance_history_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_balance_history_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get balance history  # noqa: E501

        Returns time series with historical balances (only changes, without duplicates).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_history_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param int step: Step of the time series, for example if `step = 1000` you will get balances at blocks `1000, 2000, 3000, ...`.
        :param Select1 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort4 sort: Sorts historical balances by specified field. Supported fields: `level`.
        :param int offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote1 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[HistoricalBalance]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'step', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_balance_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_balance_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'step' in params:
            query_params.append(('step', params['step']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/balance_history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HistoricalBalance]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_balance_report(self, address, **kwargs):  # noqa: E501
        """Get account report  # noqa: E501

        Exports account balance report in .csv format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_report(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param datetime _from: Start of the datetime range to filter by (ISO 8601, e.g. 2019-11-31)
        :param datetime to: End of the datetime range to filter by (ISO 8601, e.g. 2019-12-31)
        :param str currency: Currency to convert amounts to (`btc`, `eur`, `usd`, `cny`, `jpy`, `krw`, `eth`, `gbp`)
        :param bool historical: `true` if you want to use historical prices, `false` to use current price
        :param str delimiter: Column delimiter (`comma`, `semicolon`)
        :param str separator: Decimal separator (`comma`, `point`)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_balance_report_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_balance_report_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_balance_report_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account report  # noqa: E501

        Exports account balance report in .csv format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_balance_report_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param datetime _from: Start of the datetime range to filter by (ISO 8601, e.g. 2019-11-31)
        :param datetime to: End of the datetime range to filter by (ISO 8601, e.g. 2019-12-31)
        :param str currency: Currency to convert amounts to (`btc`, `eur`, `usd`, `cny`, `jpy`, `krw`, `eth`, `gbp`)
        :param bool historical: `true` if you want to use historical prices, `false` to use current price
        :param str delimiter: Column delimiter (`comma`, `semicolon`)
        :param str separator: Decimal separator (`comma`, `point`)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', '_from', 'to', 'currency', 'historical', 'delimiter', 'separator']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_balance_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_balance_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'historical' in params:
            query_params.append(('historical', params['historical']))  # noqa: E501
        if 'delimiter' in params:
            query_params.append(('delimiter', params['delimiter']))  # noqa: E501
        if 'separator' in params:
            query_params.append(('separator', params['separator']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_by_address(self, address, **kwargs):  # noqa: E501
        """Get account by address  # noqa: E501

        Returns an account with the specified address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_by_address(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param bool metadata: Include or not account metadata
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_by_address_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_by_address_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_by_address_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account by address  # noqa: E501

        Returns an account with the specified address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_by_address_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param bool metadata: Include or not account metadata
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_by_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_by_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'metadata' in params:
            query_params.append(('metadata', params['metadata']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_contracts(self, address, **kwargs):  # noqa: E501
        """Get account contracts  # noqa: E501

        Returns a list of contracts created by (or related to) the specified account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_contracts(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param Sort1 sort: Sorts contracts by specified field. Supported fields: `id` (default, desc), `balance`, `creationLevel`.
        :param Offset1 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[RelatedContract]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_contracts_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_contracts_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_contracts_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account contracts  # noqa: E501

        Returns a list of contracts created by (or related to) the specified account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_contracts_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param Sort1 sort: Sorts contracts by specified field. Supported fields: `id` (default, desc), `balance`, `creationLevel`.
        :param Offset1 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[RelatedContract]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_contracts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_contracts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RelatedContract]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_count(self, **kwargs):  # noqa: E501
        """Get accounts count  # noqa: E501

        Returns a number of accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Type1 type: Filters accounts by type (`user`, `delegate`, `contract`, `ghost`).
        :param Kind1 kind: Filters accounts by contract kind (`delegator_contract` or `smart_contract`)
        :param Balance1 balance: Filters accounts by balance
        :param Staked1 staked: Filters accounts by participation in staking
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def accounts_get_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get accounts count  # noqa: E501

        Returns a number of accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Type1 type: Filters accounts by type (`user`, `delegate`, `contract`, `ghost`).
        :param Kind1 kind: Filters accounts by contract kind (`delegator_contract` or `smart_contract`)
        :param Balance1 balance: Filters accounts by balance
        :param Staked1 staked: Filters accounts by participation in staking
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'kind', 'balance', 'staked']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'balance' in params:
            query_params.append(('balance', params['balance']))  # noqa: E501
        if 'staked' in params:
            query_params.append(('staked', params['staked']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_counter(self, address, **kwargs):  # noqa: E501
        """Get counter  # noqa: E501

        Returns account counter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_counter(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_counter_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_counter_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_counter_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get counter  # noqa: E501

        Returns account counter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_counter_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_counter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_counter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/counter', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_delegators(self, address, **kwargs):  # noqa: E501
        """Get account delegators  # noqa: E501

        Returns a list of accounts delegated to the specified account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_delegators(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz) (required)
        :param Type2 type: Filters delegators by type (`user`, `delegate`, `contract`, `ghost`).
        :param Balance2 balance: Filters delegators by balance.
        :param DelegationLevel delegation_level: Number of items to skip
        :param Sort2 sort: Sorts delegators by specified field. Supported fields: `delegationLevel` (default, desc), `balance`.
        :param Offset2 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[Delegator]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_delegators_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_delegators_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_delegators_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account delegators  # noqa: E501

        Returns a list of accounts delegated to the specified account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_delegators_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz) (required)
        :param Type2 type: Filters delegators by type (`user`, `delegate`, `contract`, `ghost`).
        :param Balance2 balance: Filters delegators by balance.
        :param DelegationLevel delegation_level: Number of items to skip
        :param Sort2 sort: Sorts delegators by specified field. Supported fields: `delegationLevel` (default, desc), `balance`.
        :param Offset2 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :return: list[Delegator]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'type', 'balance', 'delegation_level', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_delegators" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_delegators`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'balance' in params:
            query_params.append(('balance', params['balance']))  # noqa: E501
        if 'delegation_level' in params:
            query_params.append(('delegationLevel', params['delegation_level']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/delegators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Delegator]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_metadata(self, address, **kwargs):  # noqa: E501
        """Get account metadata  # noqa: E501

        Returns metadata of the specified account (alias, logo, website, contacts, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_metadata(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: ProfileMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_metadata_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_metadata_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_metadata_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account metadata  # noqa: E501

        Returns metadata of the specified account (alias, logo, website, contacts, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_metadata_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :return: ProfileMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProfileMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def accounts_get_operations(self, address, **kwargs):  # noqa: E501
        """Get account operations  # noqa: E501

        Returns a list of operations related to the specified account. Note: for better flexibility this endpoint accumulates query parameters (filters) of each `/operations/{type}` endpoint, so a particular filter may affect several operation types containing this filter. For example, if you specify an `initiator` it will affect all transactions, delegations and originations, because all these types have an `initiator` field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_operations(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param str type: Comma separated list of operation types to return (`endorsement`, `preendorsement`, `ballot`, `proposal`, `activation`, `double_baking`, `double_endorsing`, `double_preendorsing`, `nonce_revelation`, `delegation`, `origination`, `transaction`, `reveal`, `register_constant`, `set_deposits_limit`, `migration`, `revelation_penalty`, `baking`, `endorsing_reward`). If not specified then the default set will be returned.
        :param Initiator initiator: Filters transactions, delegations and originations by initiator. Allowed fields for `.eqx` mode: none.
        :param Sender sender: Filters transactions, delegations, originations, reveals and seed nonce revelations by sender. Allowed fields for `.eqx` mode: none.
        :param Target target: Filters transactions by target. Allowed fields for `.eqx` mode: none.
        :param PrevDelegate prev_delegate: Filters delegations by prev delegate. Allowed fields for `.eqx` mode: none.
        :param NewDelegate new_delegate: Filters delegations by new delegate. Allowed fields for `.eqx` mode: none.
        :param ContractManager contract_manager: Filters origination operations by manager. Allowed fields for `.eqx` mode: none.
        :param ContractDelegate contract_delegate: Filters origination operations by delegate. Allowed fields for `.eqx` mode: none.
        :param OriginatedContract originated_contract: Filters origination operations by originated contract. Allowed fields for `.eqx` mode: none.
        :param Accuser accuser: Filters double baking and double endorsing by accuser. Allowed fields for `.eqx` mode: none.
        :param Offender offender: Filters double baking and double endorsing by offender. Allowed fields for `.eqx` mode: none.
        :param Baker baker: Filters seed nonce revelation operations by baker. Allowed fields for `.eqx` mode: none.
        :param Level level: Filters operations by level.
        :param Timestamp timestamp: Filters operations by timestamp.
        :param Entrypoint entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Parameter parameter: Filters transactions by parameter value. Note, this query parameter supports the following format: `?parameter{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?parameter.token_id=...` or `?parameter.sigs.0.ne=...`.
        :param HasInternals has_internals: Filters transactions by presence of internal operations.
        :param Status status: Filters transactions, delegations, originations and reveals by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Sort3 sort: Sort mode (0 - ascending, 1 - descending), operations of different types can only be sorted by ID.
        :param int last_id: Id of the last operation received, which is used as an offset for pagination
        :param int limit: Number of items to return
        :param Micheline micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accounts_get_operations_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.accounts_get_operations_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def accounts_get_operations_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get account operations  # noqa: E501

        Returns a list of operations related to the specified account. Note: for better flexibility this endpoint accumulates query parameters (filters) of each `/operations/{type}` endpoint, so a particular filter may affect several operation types containing this filter. For example, if you specify an `initiator` it will affect all transactions, delegations and originations, because all these types have an `initiator` field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accounts_get_operations_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Account address (starting with tz or KT) (required)
        :param str type: Comma separated list of operation types to return (`endorsement`, `preendorsement`, `ballot`, `proposal`, `activation`, `double_baking`, `double_endorsing`, `double_preendorsing`, `nonce_revelation`, `delegation`, `origination`, `transaction`, `reveal`, `register_constant`, `set_deposits_limit`, `migration`, `revelation_penalty`, `baking`, `endorsing_reward`). If not specified then the default set will be returned.
        :param Initiator initiator: Filters transactions, delegations and originations by initiator. Allowed fields for `.eqx` mode: none.
        :param Sender sender: Filters transactions, delegations, originations, reveals and seed nonce revelations by sender. Allowed fields for `.eqx` mode: none.
        :param Target target: Filters transactions by target. Allowed fields for `.eqx` mode: none.
        :param PrevDelegate prev_delegate: Filters delegations by prev delegate. Allowed fields for `.eqx` mode: none.
        :param NewDelegate new_delegate: Filters delegations by new delegate. Allowed fields for `.eqx` mode: none.
        :param ContractManager contract_manager: Filters origination operations by manager. Allowed fields for `.eqx` mode: none.
        :param ContractDelegate contract_delegate: Filters origination operations by delegate. Allowed fields for `.eqx` mode: none.
        :param OriginatedContract originated_contract: Filters origination operations by originated contract. Allowed fields for `.eqx` mode: none.
        :param Accuser accuser: Filters double baking and double endorsing by accuser. Allowed fields for `.eqx` mode: none.
        :param Offender offender: Filters double baking and double endorsing by offender. Allowed fields for `.eqx` mode: none.
        :param Baker baker: Filters seed nonce revelation operations by baker. Allowed fields for `.eqx` mode: none.
        :param Level level: Filters operations by level.
        :param Timestamp timestamp: Filters operations by timestamp.
        :param Entrypoint entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Parameter parameter: Filters transactions by parameter value. Note, this query parameter supports the following format: `?parameter{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?parameter.token_id=...` or `?parameter.sigs.0.ne=...`.
        :param HasInternals has_internals: Filters transactions by presence of internal operations.
        :param Status status: Filters transactions, delegations, originations and reveals by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Sort3 sort: Sort mode (0 - ascending, 1 - descending), operations of different types can only be sorted by ID.
        :param int last_id: Id of the last operation received, which is used as an offset for pagination
        :param int limit: Number of items to return
        :param Micheline micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'type', 'initiator', 'sender', 'target', 'prev_delegate', 'new_delegate', 'contract_manager', 'contract_delegate', 'originated_contract', 'accuser', 'offender', 'baker', 'level', 'timestamp', 'entrypoint', 'parameter', 'has_internals', 'status', 'sort', 'last_id', 'limit', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accounts_get_operations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `accounts_get_operations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'initiator' in params:
            query_params.append(('initiator', params['initiator']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'target' in params:
            query_params.append(('target', params['target']))  # noqa: E501
        if 'prev_delegate' in params:
            query_params.append(('prevDelegate', params['prev_delegate']))  # noqa: E501
        if 'new_delegate' in params:
            query_params.append(('newDelegate', params['new_delegate']))  # noqa: E501
        if 'contract_manager' in params:
            query_params.append(('contractManager', params['contract_manager']))  # noqa: E501
        if 'contract_delegate' in params:
            query_params.append(('contractDelegate', params['contract_delegate']))  # noqa: E501
        if 'originated_contract' in params:
            query_params.append(('originatedContract', params['originated_contract']))  # noqa: E501
        if 'accuser' in params:
            query_params.append(('accuser', params['accuser']))  # noqa: E501
        if 'offender' in params:
            query_params.append(('offender', params['offender']))  # noqa: E501
        if 'baker' in params:
            query_params.append(('baker', params['baker']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'entrypoint' in params:
            query_params.append(('entrypoint', params['entrypoint']))  # noqa: E501
        if 'parameter' in params:
            query_params.append(('parameter', params['parameter']))  # noqa: E501
        if 'has_internals' in params:
            query_params.append(('hasInternals', params['has_internals']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{address}/operations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Operation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
