# coding: utf-8

"""
    TzKT API

    # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Hangzhounet: `https://api.hangzhounet.tzkt.io/` ([view docs](https://api.hangzhounet.tzkt.io)) - Ithacanet: `https://api.ithacanet.tzkt.io/` ([view docs](https://api.ithacanet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you must mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** or **\"Built with TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---   # noqa: E501

    OpenAPI spec version: v1.8.3
    Contact: hello@baking-bad.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class OperationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def operations_get_activation_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get activation by hash  # noqa: E501

        Returns an activation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activation_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote20 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ActivationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_activation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_activation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_activation_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get activation by hash  # noqa: E501

        Returns an activation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activation_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote20 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ActivationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_activation_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_activation_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/activations/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ActivationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_activations(self, **kwargs):  # noqa: E501
        """Get activations  # noqa: E501

        Returns a list of activation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Account account: Filters activations by account. Allowed fields for `.eqx` mode: none.
        :param Level11 level: Filters activations by level.
        :param Timestamp11 timestamp: Filters activations by timestamp.
        :param Select20 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort26 sort: Sorts activations by specified field. Supported fields: `id` (default), `level`, `balance`.
        :param Offset24 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote19 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ActivationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_activations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_activations_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_activations_with_http_info(self, **kwargs):  # noqa: E501
        """Get activations  # noqa: E501

        Returns a list of activation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Account account: Filters activations by account. Allowed fields for `.eqx` mode: none.
        :param Level11 level: Filters activations by level.
        :param Timestamp11 timestamp: Filters activations by timestamp.
        :param Select20 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort26 sort: Sorts activations by specified field. Supported fields: `id` (default), `level`, `balance`.
        :param Offset24 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote19 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ActivationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_activations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account' in params:
            query_params.append(('account', params['account']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/activations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ActivationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_activations_count(self, **kwargs):  # noqa: E501
        """Get activations count  # noqa: E501

        Returns the total number of activation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activations_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level12 level: Filters activations by level.
        :param Timestamp12 timestamp: Filters activations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_activations_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_activations_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_activations_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get activations count  # noqa: E501

        Returns the total number of activation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_activations_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level12 level: Filters activations by level.
        :param Timestamp12 timestamp: Filters activations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_activations_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/activations/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_baking(self, **kwargs):  # noqa: E501
        """Get baking  # noqa: E501

        Returns a list of baking operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker4 baker: [DEPRECATED]
        :param str anyof: Filters by any of the specified fields. Example: `anyof.proposer.producer=tz1...`.
        :param Proposer1 proposer: Filters by block proposer. Allowed fields for `.eqx` mode: none.
        :param Producer1 producer: Filters by block producer. Allowed fields for `.eqx` mode: none.
        :param Level37 level: Filters baking operations by level.
        :param Timestamp37 timestamp: Filters baking operations by timestamp.
        :param Select33 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort39 sort: Sorts baking operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset37 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote47 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_baking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_baking_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_baking_with_http_info(self, **kwargs):  # noqa: E501
        """Get baking  # noqa: E501

        Returns a list of baking operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker4 baker: [DEPRECATED]
        :param str anyof: Filters by any of the specified fields. Example: `anyof.proposer.producer=tz1...`.
        :param Proposer1 proposer: Filters by block proposer. Allowed fields for `.eqx` mode: none.
        :param Producer1 producer: Filters by block producer. Allowed fields for `.eqx` mode: none.
        :param Level37 level: Filters baking operations by level.
        :param Timestamp37 timestamp: Filters baking operations by timestamp.
        :param Select33 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort39 sort: Sorts baking operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset37 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote47 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['baker', 'anyof', 'proposer', 'producer', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_baking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'baker' in params:
            query_params.append(('baker', params['baker']))  # noqa: E501
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'proposer' in params:
            query_params.append(('proposer', params['proposer']))  # noqa: E501
        if 'producer' in params:
            query_params.append(('producer', params['producer']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/baking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BakingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_baking_by_id(self, id, **kwargs):  # noqa: E501
        """Get baking by id  # noqa: E501

        Returns baking operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote48 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: BakingOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_baking_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_baking_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def operations_get_baking_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get baking by id  # noqa: E501

        Returns baking operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote48 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: BakingOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_baking_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `operations_get_baking_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/baking/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BakingOperation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_baking_count(self, **kwargs):  # noqa: E501
        """Get baking count  # noqa: E501

        Returns the total number of baking operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level38 level: Filters baking operations by level.
        :param Timestamp38 timestamp: Filters baking operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_baking_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_baking_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_baking_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get baking count  # noqa: E501

        Returns the total number of baking operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_baking_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level38 level: Filters baking operations by level.
        :param Timestamp38 timestamp: Filters baking operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_baking_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/baking/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_ballot_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get ballot by hash  # noqa: E501

        Returns a ballot operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballot_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote16 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BallotOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_ballot_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_ballot_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_ballot_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get ballot by hash  # noqa: E501

        Returns a ballot operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballot_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote16 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BallotOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_ballot_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_ballot_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/ballots/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BallotOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_ballots(self, **kwargs):  # noqa: E501
        """Get ballots  # noqa: E501

        Returns a list of ballot operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballots(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate4 delegate: Filters ballots by delegate. Allowed fields for `.eqx` mode: none.
        :param Level7 level: Filters ballots by level.
        :param Timestamp7 timestamp: Filters ballots by timestamp.
        :param Epoch epoch: Filters ballots by voting epoch.
        :param Period period: Filters ballots by voting period.
        :param Proposal proposal: Filters ballots by proposal hash.
        :param Vote vote: Filters ballots by vote (`yay`, `nay`, `pass`).
        :param Select18 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort24 sort: Sorts ballots by specified field. Supported fields: `id` (default), `level`.
        :param Offset22 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote15 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BallotOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_ballots_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_ballots_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_ballots_with_http_info(self, **kwargs):  # noqa: E501
        """Get ballots  # noqa: E501

        Returns a list of ballot operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballots_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate4 delegate: Filters ballots by delegate. Allowed fields for `.eqx` mode: none.
        :param Level7 level: Filters ballots by level.
        :param Timestamp7 timestamp: Filters ballots by timestamp.
        :param Epoch epoch: Filters ballots by voting epoch.
        :param Period period: Filters ballots by voting period.
        :param Proposal proposal: Filters ballots by proposal hash.
        :param Vote vote: Filters ballots by vote (`yay`, `nay`, `pass`).
        :param Select18 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort24 sort: Sorts ballots by specified field. Supported fields: `id` (default), `level`.
        :param Offset22 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote15 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[BallotOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegate', 'level', 'timestamp', 'epoch', 'period', 'proposal', 'vote', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_ballots" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'epoch' in params:
            query_params.append(('epoch', params['epoch']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'proposal' in params:
            query_params.append(('proposal', params['proposal']))  # noqa: E501
        if 'vote' in params:
            query_params.append(('vote', params['vote']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/ballots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BallotOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_ballots_count(self, **kwargs):  # noqa: E501
        """Get ballots count  # noqa: E501

        Returns the total number of ballot operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballots_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level8 level: Filters ballot operations by level.
        :param Timestamp8 timestamp: Filters ballot operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_ballots_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_ballots_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_ballots_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get ballots count  # noqa: E501

        Returns the total number of ballot operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_ballots_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level8 level: Filters ballot operations by level.
        :param Timestamp8 timestamp: Filters ballot operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_ballots_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/ballots/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get operations by hash  # noqa: E501

        Returns a list of operations with the specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline19 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote8 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get operations by hash  # noqa: E501

        Returns a list of operations with the specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline19 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote8 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Operation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_by_hash_counter(self, hash, counter, **kwargs):  # noqa: E501
        """Get operations by hash and counter  # noqa: E501

        Returns a list of operations with the specified hash and counter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash_counter(hash, counter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param Micheline20 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote9 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_by_hash_counter_with_http_info(hash, counter, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_by_hash_counter_with_http_info(hash, counter, **kwargs)  # noqa: E501
            return data

    def operations_get_by_hash_counter_with_http_info(self, hash, counter, **kwargs):  # noqa: E501
        """Get operations by hash and counter  # noqa: E501

        Returns a list of operations with the specified hash and counter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash_counter_with_http_info(hash, counter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param Micheline20 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote9 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'counter', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_by_hash_counter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_by_hash_counter`")  # noqa: E501
        # verify the required parameter 'counter' is set
        if ('counter' not in params or
                params['counter'] is None):
            raise ValueError("Missing the required parameter `counter` when calling `operations_get_by_hash_counter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501
        if 'counter' in params:
            path_params['counter'] = params['counter']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/{hash}/{counter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Operation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_by_hash_counter_nonce(self, hash, counter, nonce, **kwargs):  # noqa: E501
        """Get operations by hash, counter and nonce  # noqa: E501

        Returns an internal operations with the specified hash, counter and nonce.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash_counter_nonce(hash, counter, nonce, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param int nonce: Operation nonce (internal) (required)
        :param Micheline21 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote10 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_by_hash_counter_nonce_with_http_info(hash, counter, nonce, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_by_hash_counter_nonce_with_http_info(hash, counter, nonce, **kwargs)  # noqa: E501
            return data

    def operations_get_by_hash_counter_nonce_with_http_info(self, hash, counter, nonce, **kwargs):  # noqa: E501
        """Get operations by hash, counter and nonce  # noqa: E501

        Returns an internal operations with the specified hash, counter and nonce.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_by_hash_counter_nonce_with_http_info(hash, counter, nonce, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param int nonce: Operation nonce (internal) (required)
        :param Micheline21 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote10 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[Operation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'counter', 'nonce', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_by_hash_counter_nonce" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_by_hash_counter_nonce`")  # noqa: E501
        # verify the required parameter 'counter' is set
        if ('counter' not in params or
                params['counter'] is None):
            raise ValueError("Missing the required parameter `counter` when calling `operations_get_by_hash_counter_nonce`")  # noqa: E501
        # verify the required parameter 'nonce' is set
        if ('nonce' not in params or
                params['nonce'] is None):
            raise ValueError("Missing the required parameter `nonce` when calling `operations_get_by_hash_counter_nonce`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501
        if 'counter' in params:
            path_params['counter'] = params['counter']  # noqa: E501
        if 'nonce' in params:
            path_params['nonce'] = params['nonce']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/{hash}/{counter}/{nonce}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Operation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_delegation_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get delegation by hash  # noqa: E501

        Returns a delegation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegation_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote30 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DelegationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_delegation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_delegation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_delegation_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get delegation by hash  # noqa: E501

        Returns a delegation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegation_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote30 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DelegationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_delegation_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_delegation_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/delegations/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DelegationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_delegations(self, **kwargs):  # noqa: E501
        """Get delegations  # noqa: E501

        Returns a list of delegation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters delegations by any of the specified fields. Example: `anyof.prevDelegate.newDelegate=tz1...` will return operations where `prevDelegate` OR `newDelegate` is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account.
        :param Initiator1 initiator: Filters delegations by initiator. Allowed fields for `.eqx` mode: `prevDelegate`, `newDelegate`.
        :param Sender2 sender: Filters delegations by sender. Allowed fields for `.eqx` mode: `prevDelegate`, `newDelegate`.
        :param PrevDelegate1 prev_delegate: Filters delegations by prev delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `newDelegate`.
        :param NewDelegate1 new_delegate: Filters delegations by new delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `prevDelegate`.
        :param Level21 level: Filters delegations by level.
        :param Timestamp21 timestamp: Filters delegations by timestamp.
        :param Status1 status: Filters delegations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select25 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort31 sort: Sorts delegations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset29 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote29 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DelegationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_delegations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_delegations_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_delegations_with_http_info(self, **kwargs):  # noqa: E501
        """Get delegations  # noqa: E501

        Returns a list of delegation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters delegations by any of the specified fields. Example: `anyof.prevDelegate.newDelegate=tz1...` will return operations where `prevDelegate` OR `newDelegate` is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account.
        :param Initiator1 initiator: Filters delegations by initiator. Allowed fields for `.eqx` mode: `prevDelegate`, `newDelegate`.
        :param Sender2 sender: Filters delegations by sender. Allowed fields for `.eqx` mode: `prevDelegate`, `newDelegate`.
        :param PrevDelegate1 prev_delegate: Filters delegations by prev delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `newDelegate`.
        :param NewDelegate1 new_delegate: Filters delegations by new delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `prevDelegate`.
        :param Level21 level: Filters delegations by level.
        :param Timestamp21 timestamp: Filters delegations by timestamp.
        :param Status1 status: Filters delegations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select25 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort31 sort: Sorts delegations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset29 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote29 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DelegationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'initiator', 'sender', 'prev_delegate', 'new_delegate', 'level', 'timestamp', 'status', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_delegations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'initiator' in params:
            query_params.append(('initiator', params['initiator']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'prev_delegate' in params:
            query_params.append(('prevDelegate', params['prev_delegate']))  # noqa: E501
        if 'new_delegate' in params:
            query_params.append(('newDelegate', params['new_delegate']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/delegations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DelegationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_delegations_count(self, **kwargs):  # noqa: E501
        """Get delegations count  # noqa: E501

        Returns the total number of delegation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegations_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level22 level: Filters delegations by level.
        :param Timestamp22 timestamp: Filters delegations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_delegations_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_delegations_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_delegations_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get delegations count  # noqa: E501

        Returns the total number of delegation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_delegations_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level22 level: Filters delegations by level.
        :param Timestamp22 timestamp: Filters delegations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_delegations_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/delegations/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_baking(self, **kwargs):  # noqa: E501
        """Get double baking  # noqa: E501

        Returns a list of double baking operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters double baking operations by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser1 accuser: Filters double baking operations by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender1 offender: Filters double baking operations by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level13 level: Filters double baking operations by level.
        :param Timestamp13 timestamp: Filters double baking operations by timestamp.
        :param Select21 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort27 sort: Sorts double baking operations by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset25 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote21 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleBakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_baking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_baking_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_baking_with_http_info(self, **kwargs):  # noqa: E501
        """Get double baking  # noqa: E501

        Returns a list of double baking operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters double baking operations by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser1 accuser: Filters double baking operations by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender1 offender: Filters double baking operations by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level13 level: Filters double baking operations by level.
        :param Timestamp13 timestamp: Filters double baking operations by timestamp.
        :param Select21 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort27 sort: Sorts double baking operations by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset25 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote21 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleBakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'accuser', 'offender', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_baking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'accuser' in params:
            query_params.append(('accuser', params['accuser']))  # noqa: E501
        if 'offender' in params:
            query_params.append(('offender', params['offender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_baking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoubleBakingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_baking_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get double baking by hash  # noqa: E501

        Returns a double baking operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote22 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleBakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_baking_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_baking_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_double_baking_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get double baking by hash  # noqa: E501

        Returns a double baking operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote22 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleBakingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_baking_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_double_baking_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_baking/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoubleBakingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_baking_count(self, **kwargs):  # noqa: E501
        """Get double baking count  # noqa: E501

        Returns the total number of double baking operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level14 level: Filters double baking operations by level.
        :param Timestamp14 timestamp: Filters double baking operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_baking_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_baking_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_baking_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get double baking count  # noqa: E501

        Returns the total number of double baking operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_baking_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level14 level: Filters double baking operations by level.
        :param Timestamp14 timestamp: Filters double baking operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_baking_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_baking/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_endorsing(self, **kwargs):  # noqa: E501
        """Get double endorsing  # noqa: E501

        Returns a list of double endorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters double endorsing operations by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser2 accuser: Filters double endorsing operations by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender2 offender: Filters double endorsing operations by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level15 level: Filters double endorsing operations by level.
        :param Timestamp15 timestamp: Filters double endorsing operations by timestamp.
        :param Select22 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort28 sort: Sorts double endorsing operations by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset26 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote23 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleEndorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_endorsing_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_endorsing_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_endorsing_with_http_info(self, **kwargs):  # noqa: E501
        """Get double endorsing  # noqa: E501

        Returns a list of double endorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters double endorsing operations by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser2 accuser: Filters double endorsing operations by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender2 offender: Filters double endorsing operations by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level15 level: Filters double endorsing operations by level.
        :param Timestamp15 timestamp: Filters double endorsing operations by timestamp.
        :param Select22 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort28 sort: Sorts double endorsing operations by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset26 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote23 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleEndorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'accuser', 'offender', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_endorsing" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'accuser' in params:
            query_params.append(('accuser', params['accuser']))  # noqa: E501
        if 'offender' in params:
            query_params.append(('offender', params['offender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_endorsing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoubleEndorsingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_endorsing_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get double endorsing by hash  # noqa: E501

        Returns a double endorsing operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote24 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleEndorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_endorsing_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_endorsing_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_double_endorsing_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get double endorsing by hash  # noqa: E501

        Returns a double endorsing operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote24 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoubleEndorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_endorsing_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_double_endorsing_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_endorsing/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoubleEndorsingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_endorsing_count(self, **kwargs):  # noqa: E501
        """Get double endorsing count  # noqa: E501

        Returns the total number of double endorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level16 level: Filters double endorsing operations by level.
        :param Timestamp16 timestamp: Filters double endorsing operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_endorsing_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_endorsing_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_endorsing_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get double endorsing count  # noqa: E501

        Returns the total number of double endorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_endorsing_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level16 level: Filters double endorsing operations by level.
        :param Timestamp16 timestamp: Filters double endorsing operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_endorsing_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_endorsing/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_preendorsing(self, **kwargs):  # noqa: E501
        """Get double preendorsing  # noqa: E501

        Returns a list of double preendorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser3 accuser: Filters by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender3 offender: Filters by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level17 level: Filters by level.
        :param Timestamp17 timestamp: Filters by timestamp.
        :param Select23 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort29 sort: Sorts by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset27 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote25 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoublePreendorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_preendorsing_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_preendorsing_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_preendorsing_with_http_info(self, **kwargs):  # noqa: E501
        """Get double preendorsing  # noqa: E501

        Returns a list of double preendorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters by any of the specified fields. Example: `anyof.accuser.offender=tz1...` will return operations where `accuser` OR `offender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Accuser3 accuser: Filters by accuser. Allowed fields for `.eqx` mode: `offender`.
        :param Offender3 offender: Filters by offender. Allowed fields for `.eqx` mode: `accuser`.
        :param Level17 level: Filters by level.
        :param Timestamp17 timestamp: Filters by timestamp.
        :param Select23 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort29 sort: Sorts by specified field. Supported fields: `id` (default), `level`, `accusedLevel`, `accuserRewards`, `offenderLostDeposits`, `offenderLostRewards`, `offenderLostFees`.
        :param Offset27 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote25 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoublePreendorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'accuser', 'offender', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_preendorsing" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'accuser' in params:
            query_params.append(('accuser', params['accuser']))  # noqa: E501
        if 'offender' in params:
            query_params.append(('offender', params['offender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_preendorsing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoublePreendorsingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_preendorsing_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get double preendorsing by hash  # noqa: E501

        Returns a double preendorsing operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote26 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoublePreendorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_preendorsing_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_preendorsing_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_double_preendorsing_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get double preendorsing by hash  # noqa: E501

        Returns a double preendorsing operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote26 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[DoublePreendorsingOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_preendorsing_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_double_preendorsing_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_preendorsing/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DoublePreendorsingOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_double_preendorsing_count(self, **kwargs):  # noqa: E501
        """Get double preendorsing count  # noqa: E501

        Returns the total number of double preendorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level18 level: Filters by level.
        :param Timestamp18 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_double_preendorsing_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_double_preendorsing_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_double_preendorsing_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get double preendorsing count  # noqa: E501

        Returns the total number of double preendorsing operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_double_preendorsing_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level18 level: Filters by level.
        :param Timestamp18 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_double_preendorsing_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/double_preendorsing/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsement_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get endorsement by hash  # noqa: E501

        Returns an endorsement operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsement_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote12 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsement_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsement_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_endorsement_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get endorsement by hash  # noqa: E501

        Returns an endorsement operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsement_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote12 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsement_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_endorsement_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsements/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndorsementOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsements(self, **kwargs):  # noqa: E501
        """Get endorsements  # noqa: E501

        Returns a list of endorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsements(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate2 delegate: Filters endorsements by delegate. Allowed fields for `.eqx` mode: none.
        :param Level3 level: Filters endorsements by level.
        :param Timestamp3 timestamp: Filters endorsements by timestamp.
        :param Select16 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort22 sort: Sorts endorsements by specified field. Supported fields: `id` (default), `level`.
        :param Offset20 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote11 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsements_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsements_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_endorsements_with_http_info(self, **kwargs):  # noqa: E501
        """Get endorsements  # noqa: E501

        Returns a list of endorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsements_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate2 delegate: Filters endorsements by delegate. Allowed fields for `.eqx` mode: none.
        :param Level3 level: Filters endorsements by level.
        :param Timestamp3 timestamp: Filters endorsements by timestamp.
        :param Select16 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort22 sort: Sorts endorsements by specified field. Supported fields: `id` (default), `level`.
        :param Offset20 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote11 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegate', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsements" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndorsementOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsements_count(self, **kwargs):  # noqa: E501
        """Get endorsements count  # noqa: E501

        Returns the total number of endorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsements_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level4 level: Filters endorsements by level.
        :param Timestamp4 timestamp: Filters endorsements by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsements_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsements_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_endorsements_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get endorsements count  # noqa: E501

        Returns the total number of endorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsements_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level4 level: Filters endorsements by level.
        :param Timestamp4 timestamp: Filters endorsements by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsements_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsements/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsing_reward_by_id(self, id, **kwargs):  # noqa: E501
        """Get endorsing reward by id  # noqa: E501

        Returns endorsing reward operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_reward_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote50 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: EndorsingRewardOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsing_reward_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsing_reward_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def operations_get_endorsing_reward_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get endorsing reward by id  # noqa: E501

        Returns endorsing reward operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_reward_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote50 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: EndorsingRewardOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsing_reward_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `operations_get_endorsing_reward_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsing_rewards/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EndorsingRewardOperation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsing_rewards(self, **kwargs):  # noqa: E501
        """Get endorsing rewards  # noqa: E501

        Returns a list of endorsing reward operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_rewards(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker5 baker: Filters by baker. Allowed fields for `.eqx` mode: none.
        :param Level39 level: Filters by level.
        :param Timestamp39 timestamp: Filters by timestamp.
        :param Select34 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort40 sort: Sorts by specified field. Supported fields: `id` (default), `level`.
        :param Offset38 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote49 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsingRewardOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsing_rewards_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsing_rewards_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_endorsing_rewards_with_http_info(self, **kwargs):  # noqa: E501
        """Get endorsing rewards  # noqa: E501

        Returns a list of endorsing reward operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_rewards_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker5 baker: Filters by baker. Allowed fields for `.eqx` mode: none.
        :param Level39 level: Filters by level.
        :param Timestamp39 timestamp: Filters by timestamp.
        :param Select34 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort40 sort: Sorts by specified field. Supported fields: `id` (default), `level`.
        :param Offset38 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote49 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[EndorsingRewardOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['baker', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsing_rewards" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'baker' in params:
            query_params.append(('baker', params['baker']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsing_rewards', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndorsingRewardOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_endorsing_rewards_count(self, **kwargs):  # noqa: E501
        """Get endorsing rewards count  # noqa: E501

        Returns the total number of endorsing reward operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_rewards_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level40 level: Filters by level.
        :param Timestamp40 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_endorsing_rewards_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_endorsing_rewards_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_endorsing_rewards_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get endorsing rewards count  # noqa: E501

        Returns the total number of endorsing reward operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_endorsing_rewards_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level40 level: Filters by level.
        :param Timestamp40 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_endorsing_rewards_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/endorsing_rewards/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_migration_by_id(self, id, **kwargs):  # noqa: E501
        """Get migration by id  # noqa: E501

        Returns migration operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migration_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Micheline30 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote44 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: MigrationOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_migration_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_migration_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def operations_get_migration_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get migration by id  # noqa: E501

        Returns migration operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migration_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Micheline30 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote44 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: MigrationOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_migration_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `operations_get_migration_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/migrations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MigrationOperation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_migrations(self, **kwargs):  # noqa: E501
        """Get migrations  # noqa: E501

        Returns a list of migration operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migrations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Account1 account: Filters migration operations by account. Allowed fields for `.eqx` mode: none.
        :param Kind4 kind: Filters migration operations by kind (`bootstrap`, `activate_delegate`, `airdrop`, `proposal_invoice`, `origination`, `subsidy`).
        :param BalanceChange balance_change: Filters migration operations by amount.
        :param Id2 id: Filters migration operations by internal TzKT id.
        :param Level33 level: Filters migration operations by level.
        :param Timestamp33 timestamp: Filters migration operations by timestamp.
        :param Select31 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort37 sort: Sorts migrations by specified field. Supported fields: `id` (default), `level`.
        :param Offset35 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline29 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote43 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[MigrationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_migrations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_migrations_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_migrations_with_http_info(self, **kwargs):  # noqa: E501
        """Get migrations  # noqa: E501

        Returns a list of migration operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migrations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Account1 account: Filters migration operations by account. Allowed fields for `.eqx` mode: none.
        :param Kind4 kind: Filters migration operations by kind (`bootstrap`, `activate_delegate`, `airdrop`, `proposal_invoice`, `origination`, `subsidy`).
        :param BalanceChange balance_change: Filters migration operations by amount.
        :param Id2 id: Filters migration operations by internal TzKT id.
        :param Level33 level: Filters migration operations by level.
        :param Timestamp33 timestamp: Filters migration operations by timestamp.
        :param Select31 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort37 sort: Sorts migrations by specified field. Supported fields: `id` (default), `level`.
        :param Offset35 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline29 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote43 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[MigrationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account', 'kind', 'balance_change', 'id', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_migrations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'account' in params:
            query_params.append(('account', params['account']))  # noqa: E501
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'balance_change' in params:
            query_params.append(('balanceChange', params['balance_change']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/migrations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MigrationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_migrations_count(self, **kwargs):  # noqa: E501
        """Get migrations count  # noqa: E501

        Returns the total number of migration operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migrations_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level34 level: Filters migrations by level.
        :param Timestamp34 timestamp: Filters migrations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_migrations_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_migrations_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_migrations_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get migrations count  # noqa: E501

        Returns the total number of migration operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_migrations_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level34 level: Filters migrations by level.
        :param Timestamp34 timestamp: Filters migrations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_migrations_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/migrations/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_nonce_revelation_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get nonce revelation by hash  # noqa: E501

        Returns a seed nonce revelation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelation_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote28 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[NonceRevelationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_nonce_revelation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_nonce_revelation_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_nonce_revelation_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get nonce revelation by hash  # noqa: E501

        Returns a seed nonce revelation operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelation_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote28 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[NonceRevelationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_nonce_revelation_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_nonce_revelation_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/nonce_revelations/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NonceRevelationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_nonce_revelations(self, **kwargs):  # noqa: E501
        """Get nonce revelations  # noqa: E501

        Returns a list of seed nonce revelation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters nonce revelation operations by any of the specified fields. Example: `anyof.baker.sender=tz1...` will return operations where `baker` OR `sender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Baker2 baker: Filters nonce revelation operations by baker. Allowed fields for `.eqx` mode: `sender`.
        :param Sender1 sender: Filters nonce revelation operations by sender. Allowed fields for `.eqx` mode: `baker`.
        :param Level19 level: Filters nonce revelation operations by level.
        :param RevealedCycle revealed_cycle: Filters by cycle for which the nonce was revealed.
        :param Timestamp19 timestamp: Filters nonce revelation operations by timestamp.
        :param Select24 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort30 sort: Sorts nonce revelation operations by specified field. Supported fields: `id` (default), `level`, `revealedLevel`.
        :param Offset28 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote27 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[NonceRevelationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_nonce_revelations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_nonce_revelations_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_nonce_revelations_with_http_info(self, **kwargs):  # noqa: E501
        """Get nonce revelations  # noqa: E501

        Returns a list of seed nonce revelation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters nonce revelation operations by any of the specified fields. Example: `anyof.baker.sender=tz1...` will return operations where `baker` OR `sender` is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account.
        :param Baker2 baker: Filters nonce revelation operations by baker. Allowed fields for `.eqx` mode: `sender`.
        :param Sender1 sender: Filters nonce revelation operations by sender. Allowed fields for `.eqx` mode: `baker`.
        :param Level19 level: Filters nonce revelation operations by level.
        :param RevealedCycle revealed_cycle: Filters by cycle for which the nonce was revealed.
        :param Timestamp19 timestamp: Filters nonce revelation operations by timestamp.
        :param Select24 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort30 sort: Sorts nonce revelation operations by specified field. Supported fields: `id` (default), `level`, `revealedLevel`.
        :param Offset28 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote27 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[NonceRevelationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'baker', 'sender', 'level', 'revealed_cycle', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_nonce_revelations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'baker' in params:
            query_params.append(('baker', params['baker']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'revealed_cycle' in params:
            query_params.append(('revealedCycle', params['revealed_cycle']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/nonce_revelations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NonceRevelationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_nonce_revelations_count(self, **kwargs):  # noqa: E501
        """Get nonce revelations count  # noqa: E501

        Returns the total number of seed nonce revelation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelations_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level20 level: Filters seed nonce revelation operations by level.
        :param Timestamp20 timestamp: Filters seed nonce revelation operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_nonce_revelations_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_nonce_revelations_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_nonce_revelations_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get nonce revelations count  # noqa: E501

        Returns the total number of seed nonce revelation operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_nonce_revelations_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level20 level: Filters seed nonce revelation operations by level.
        :param Timestamp20 timestamp: Filters seed nonce revelation operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_nonce_revelations_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/nonce_revelations/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_origination_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get origination by hash  # noqa: E501

        Returns origination operations with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_origination_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param MichelineFormat micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote32 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[OriginationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_origination_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_origination_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_origination_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get origination by hash  # noqa: E501

        Returns origination operations with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_origination_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param MichelineFormat micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote32 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[OriginationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_origination_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_origination_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/originations/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OriginationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_originations(self, **kwargs):  # noqa: E501
        """Get originations  # noqa: E501

        Returns a list of origination operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_originations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters originations by any of the specified fields. Example: `anyof.sender.initiator=tz1...` will return operations where `sender` OR `initiator` is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account.
        :param Initiator2 initiator: Filters origination operations by initiator. Allowed fields for `.eqx` mode: `contractManager`, `contractDelegate`.
        :param Sender3 sender: Filters origination operations by sender. Allowed fields for `.eqx` mode: `contractManager`, `contractDelegate`.
        :param ContractManager1 contract_manager: Filters origination operations by manager. Allowed fields for `.eqx` mode: `initiator`, `sender`, `contractDelegate`.
        :param ContractDelegate1 contract_delegate: Filters origination operations by delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `contractManager`.
        :param OriginatedContract1 originated_contract: Filters origination operations by originated contract. Allowed fields for `.eqx` mode: none.
        :param Id id: Filters origination operations by internal TzKT id
        :param TypeHash1 type_hash: Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts)
        :param CodeHash1 code_hash: Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts)
        :param Level23 level: Filters origination operations by level.
        :param Timestamp23 timestamp: Filters origination operations by timestamp.
        :param Status2 status: Filters origination operations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select26 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort32 sort: Sorts originations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`, `allocationFee`, `contractBalance`.
        :param Offset30 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline22 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote31 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[OriginationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_originations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_originations_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_originations_with_http_info(self, **kwargs):  # noqa: E501
        """Get originations  # noqa: E501

        Returns a list of origination operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_originations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters originations by any of the specified fields. Example: `anyof.sender.initiator=tz1...` will return operations where `sender` OR `initiator` is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account.
        :param Initiator2 initiator: Filters origination operations by initiator. Allowed fields for `.eqx` mode: `contractManager`, `contractDelegate`.
        :param Sender3 sender: Filters origination operations by sender. Allowed fields for `.eqx` mode: `contractManager`, `contractDelegate`.
        :param ContractManager1 contract_manager: Filters origination operations by manager. Allowed fields for `.eqx` mode: `initiator`, `sender`, `contractDelegate`.
        :param ContractDelegate1 contract_delegate: Filters origination operations by delegate. Allowed fields for `.eqx` mode: `initiator`, `sender`, `contractManager`.
        :param OriginatedContract1 originated_contract: Filters origination operations by originated contract. Allowed fields for `.eqx` mode: none.
        :param Id id: Filters origination operations by internal TzKT id
        :param TypeHash1 type_hash: Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts)
        :param CodeHash1 code_hash: Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts)
        :param Level23 level: Filters origination operations by level.
        :param Timestamp23 timestamp: Filters origination operations by timestamp.
        :param Status2 status: Filters origination operations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select26 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort32 sort: Sorts originations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`, `allocationFee`, `contractBalance`.
        :param Offset30 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline22 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote31 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[OriginationOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'initiator', 'sender', 'contract_manager', 'contract_delegate', 'originated_contract', 'id', 'type_hash', 'code_hash', 'level', 'timestamp', 'status', 'select', 'sort', 'offset', 'limit', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_originations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'initiator' in params:
            query_params.append(('initiator', params['initiator']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'contract_manager' in params:
            query_params.append(('contractManager', params['contract_manager']))  # noqa: E501
        if 'contract_delegate' in params:
            query_params.append(('contractDelegate', params['contract_delegate']))  # noqa: E501
        if 'originated_contract' in params:
            query_params.append(('originatedContract', params['originated_contract']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'type_hash' in params:
            query_params.append(('typeHash', params['type_hash']))  # noqa: E501
        if 'code_hash' in params:
            query_params.append(('codeHash', params['code_hash']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/originations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OriginationOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_originations_count(self, **kwargs):  # noqa: E501
        """Get originations count  # noqa: E501

        Returns the total number of origination operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_originations_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level24 level: Filters originations by level.
        :param Timestamp24 timestamp: Filters originations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_originations_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_originations_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_originations_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get originations count  # noqa: E501

        Returns the total number of origination operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_originations_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level24 level: Filters originations by level.
        :param Timestamp24 timestamp: Filters originations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_originations_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/originations/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_preendorsement_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get preendorsement by hash  # noqa: E501

        Returns an preendorsement operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsement_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote14 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[PreendorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_preendorsement_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_preendorsement_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_preendorsement_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get preendorsement by hash  # noqa: E501

        Returns an preendorsement operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsement_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote14 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[PreendorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_preendorsement_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_preendorsement_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/preendorsements/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PreendorsementOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_preendorsements(self, **kwargs):  # noqa: E501
        """Get preendorsements  # noqa: E501

        Returns a list of preendorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsements(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate3 delegate: Filters by delegate. Allowed fields for `.eqx` mode: none.
        :param Level5 level: Filters by level.
        :param Timestamp5 timestamp: Filters by timestamp.
        :param Select17 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort23 sort: Sorts by specified field. Supported fields: `id` (default), `level`.
        :param Offset21 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote13 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[PreendorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_preendorsements_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_preendorsements_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_preendorsements_with_http_info(self, **kwargs):  # noqa: E501
        """Get preendorsements  # noqa: E501

        Returns a list of preendorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsements_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate3 delegate: Filters by delegate. Allowed fields for `.eqx` mode: none.
        :param Level5 level: Filters by level.
        :param Timestamp5 timestamp: Filters by timestamp.
        :param Select17 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort23 sort: Sorts by specified field. Supported fields: `id` (default), `level`.
        :param Offset21 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote13 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[PreendorsementOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegate', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_preendorsements" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/preendorsements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PreendorsementOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_preendorsements_count(self, **kwargs):  # noqa: E501
        """Get preendorsements count  # noqa: E501

        Returns the total number of preendorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsements_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level6 level: Filters by level.
        :param Timestamp6 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_preendorsements_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_preendorsements_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_preendorsements_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get preendorsements count  # noqa: E501

        Returns the total number of preendorsement operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_preendorsements_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level6 level: Filters by level.
        :param Timestamp6 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_preendorsements_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/preendorsements/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_proposal_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get proposal by hash  # noqa: E501

        Returns a proposal operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposal_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote18 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ProposalOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_proposal_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_proposal_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_proposal_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get proposal by hash  # noqa: E501

        Returns a proposal operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposal_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote18 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ProposalOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_proposal_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_proposal_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/proposals/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProposalOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_proposals(self, **kwargs):  # noqa: E501
        """Get proposals  # noqa: E501

        Returns a list of proposal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposals(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate5 delegate: Filters proposal operations by delegate. Allowed fields for `.eqx` mode: none.
        :param Level9 level: Filters proposal operations by level.
        :param Timestamp9 timestamp: Filters proposal operations by timestamp.
        :param Epoch1 epoch: Filters proposal operations by voting epoch.
        :param Period1 period: Filters proposal operations by voting period.
        :param Proposal1 proposal: Filters proposal operations by proposal hash.
        :param Duplicated duplicated: Specify whether to include or exclude duplicates, which didn't actually upvote a proposal.
        :param Select19 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort25 sort: Sorts proposal operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset23 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote17 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ProposalOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_proposals_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_proposals_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_proposals_with_http_info(self, **kwargs):  # noqa: E501
        """Get proposals  # noqa: E501

        Returns a list of proposal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Delegate5 delegate: Filters proposal operations by delegate. Allowed fields for `.eqx` mode: none.
        :param Level9 level: Filters proposal operations by level.
        :param Timestamp9 timestamp: Filters proposal operations by timestamp.
        :param Epoch1 epoch: Filters proposal operations by voting epoch.
        :param Period1 period: Filters proposal operations by voting period.
        :param Proposal1 proposal: Filters proposal operations by proposal hash.
        :param Duplicated duplicated: Specify whether to include or exclude duplicates, which didn't actually upvote a proposal.
        :param Select19 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort25 sort: Sorts proposal operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset23 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote17 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[ProposalOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delegate', 'level', 'timestamp', 'epoch', 'period', 'proposal', 'duplicated', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_proposals" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'epoch' in params:
            query_params.append(('epoch', params['epoch']))  # noqa: E501
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'proposal' in params:
            query_params.append(('proposal', params['proposal']))  # noqa: E501
        if 'duplicated' in params:
            query_params.append(('duplicated', params['duplicated']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/proposals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProposalOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_proposals_count(self, **kwargs):  # noqa: E501
        """Get proposals count  # noqa: E501

        Returns the total number of proposal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposals_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level10 level: Filters proposal operations by level.
        :param Timestamp10 timestamp: Filters proposal operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_proposals_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_proposals_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_proposals_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get proposals count  # noqa: E501

        Returns the total number of proposal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_proposals_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level10 level: Filters proposal operations by level.
        :param Timestamp10 timestamp: Filters proposal operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_proposals_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/proposals/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_register_constant_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get register constant by hash  # noqa: E501

        Returns register global constant operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constant_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline28 micheline: Format of the constant value: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote40 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RegisterConstantOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_register_constant_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_register_constant_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_register_constant_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get register constant by hash  # noqa: E501

        Returns register global constant operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constant_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline28 micheline: Format of the constant value: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote40 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RegisterConstantOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_register_constant_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_register_constant_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/register_constants/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RegisterConstantOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_register_constants(self, **kwargs):  # noqa: E501
        """Get register constants  # noqa: E501

        Returns a list of register global constant operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constants(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender7 sender: Filters operations by sender. Allowed fields for `.eqx` mode: none.
        :param Address1 address: Filters operations by global address of the created constant (starts with `expr..`).
        :param Level29 level: Filters operations by level.
        :param Timestamp29 timestamp: Filters operations by timestamp.
        :param Status6 status: Filters operations by status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select29 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort35 sort: Sorts operations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`.
        :param Offset33 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline27 micheline: Format of the constant value: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote39 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RegisterConstantOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_register_constants_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_register_constants_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_register_constants_with_http_info(self, **kwargs):  # noqa: E501
        """Get register constants  # noqa: E501

        Returns a list of register global constant operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constants_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender7 sender: Filters operations by sender. Allowed fields for `.eqx` mode: none.
        :param Address1 address: Filters operations by global address of the created constant (starts with `expr..`).
        :param Level29 level: Filters operations by level.
        :param Timestamp29 timestamp: Filters operations by timestamp.
        :param Status6 status: Filters operations by status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select29 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort35 sort: Sorts operations by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`.
        :param Offset33 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline27 micheline: Format of the constant value: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote39 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RegisterConstantOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sender', 'address', 'level', 'timestamp', 'status', 'select', 'sort', 'offset', 'limit', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_register_constants" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/register_constants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RegisterConstantOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_register_constants_count(self, **kwargs):  # noqa: E501
        """Get register constants count  # noqa: E501

        Returns the total number of register global constant operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constants_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level30 level: Filters operations by level.
        :param Timestamp30 timestamp: Filters operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_register_constants_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_register_constants_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_register_constants_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get register constants count  # noqa: E501

        Returns the total number of register global constant operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_register_constants_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level30 level: Filters operations by level.
        :param Timestamp30 timestamp: Filters operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_register_constants_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/register_constants/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_reveal_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get reveal by hash  # noqa: E501

        Returns reveal operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveal_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote38 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevealOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_reveal_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_reveal_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_reveal_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get reveal by hash  # noqa: E501

        Returns reveal operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveal_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote38 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevealOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_reveal_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_reveal_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/reveals/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RevealOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_reveals(self, **kwargs):  # noqa: E501
        """Get reveals  # noqa: E501

        Returns a list of reveal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveals(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender6 sender: Filters reveal operations by sender. Allowed fields for `.eqx` mode: none.
        :param Level27 level: Filters reveal operations by level.
        :param Timestamp27 timestamp: Filters reveal operations by timestamp.
        :param Status5 status: Filters reveal operations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select28 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort34 sort: Sorts reveals by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset32 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote37 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevealOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_reveals_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_reveals_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_reveals_with_http_info(self, **kwargs):  # noqa: E501
        """Get reveals  # noqa: E501

        Returns a list of reveal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender6 sender: Filters reveal operations by sender. Allowed fields for `.eqx` mode: none.
        :param Level27 level: Filters reveal operations by level.
        :param Timestamp27 timestamp: Filters reveal operations by timestamp.
        :param Status5 status: Filters reveal operations by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select28 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort34 sort: Sorts reveals by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset32 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote37 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevealOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sender', 'level', 'timestamp', 'status', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_reveals" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/reveals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RevealOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_reveals_count(self, **kwargs):  # noqa: E501
        """Get reveals count  # noqa: E501

        Returns the total number of reveal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveals_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level28 level: Filters reveals by level.
        :param Timestamp28 timestamp: Filters reveals by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_reveals_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_reveals_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_reveals_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get reveals count  # noqa: E501

        Returns the total number of reveal operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_reveals_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level28 level: Filters reveals by level.
        :param Timestamp28 timestamp: Filters reveals by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_reveals_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/reveals/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_revelation_penalties(self, **kwargs):  # noqa: E501
        """Get revelation penalties  # noqa: E501

        Returns a list of revelation penalty operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalties(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker3 baker: Filters revelation penalty operations by baker. Allowed fields for `.eqx` mode: none.
        :param Level35 level: Filters revelation penalty operations by level.
        :param Timestamp35 timestamp: Filters revelation penalty operations by timestamp.
        :param Select32 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort38 sort: Sorts revelation penalty operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset36 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote45 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevelationPenaltyOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_revelation_penalties_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_revelation_penalties_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_revelation_penalties_with_http_info(self, **kwargs):  # noqa: E501
        """Get revelation penalties  # noqa: E501

        Returns a list of revelation penalty operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalties_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Baker3 baker: Filters revelation penalty operations by baker. Allowed fields for `.eqx` mode: none.
        :param Level35 level: Filters revelation penalty operations by level.
        :param Timestamp35 timestamp: Filters revelation penalty operations by timestamp.
        :param Select32 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort38 sort: Sorts revelation penalty operations by specified field. Supported fields: `id` (default), `level`.
        :param Offset36 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote45 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[RevelationPenaltyOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['baker', 'level', 'timestamp', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_revelation_penalties" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'baker' in params:
            query_params.append(('baker', params['baker']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/revelation_penalties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RevelationPenaltyOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_revelation_penalties_count(self, **kwargs):  # noqa: E501
        """Get revelation penalties count  # noqa: E501

        Returns the total number of revelation penalty operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalties_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level36 level: Filters revelation penalty operations by level.
        :param Timestamp36 timestamp: Filters revelation penalty operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_revelation_penalties_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_revelation_penalties_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_revelation_penalties_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get revelation penalties count  # noqa: E501

        Returns the total number of revelation penalty operations (synthetic type).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalties_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level36 level: Filters revelation penalty operations by level.
        :param Timestamp36 timestamp: Filters revelation penalty operations by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_revelation_penalties_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/revelation_penalties/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_revelation_penalty_by_id(self, id, **kwargs):  # noqa: E501
        """Get revelation penalty by id  # noqa: E501

        Returns revelation penalty operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalty_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote46 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: RevelationPenaltyOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_revelation_penalty_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_revelation_penalty_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def operations_get_revelation_penalty_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get revelation penalty by id  # noqa: E501

        Returns revelation penalty operation with specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_revelation_penalty_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Operation id (required)
        :param Quote46 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: RevelationPenaltyOperation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_revelation_penalty_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `operations_get_revelation_penalty_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/revelation_penalties/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevelationPenaltyOperation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_set_deposits_limit_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get set deposits limit by hash  # noqa: E501

        Returns set deposits limit operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limit_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote42 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[SetDepositsLimitOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_set_deposits_limit_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_set_deposits_limit_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_set_deposits_limit_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get set deposits limit by hash  # noqa: E501

        Returns set deposits limit operation with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limit_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Quote42 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[SetDepositsLimitOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_set_deposits_limit_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_set_deposits_limit_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/set_deposits_limits/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SetDepositsLimitOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_set_deposits_limits(self, **kwargs):  # noqa: E501
        """Get set deposits limits  # noqa: E501

        Returns a list of set deposits limit operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limits(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender8 sender: Filters by sender. Allowed fields for `.eqx` mode: none.
        :param Level31 level: Filters by level.
        :param Timestamp31 timestamp: Filters by timestamp.
        :param Status7 status: Filters by status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select30 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort36 sort: Sorts by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset34 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote41 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[SetDepositsLimitOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_set_deposits_limits_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_set_deposits_limits_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_set_deposits_limits_with_http_info(self, **kwargs):  # noqa: E501
        """Get set deposits limits  # noqa: E501

        Returns a list of set deposits limit operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limits_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Sender8 sender: Filters by sender. Allowed fields for `.eqx` mode: none.
        :param Level31 level: Filters by level.
        :param Timestamp31 timestamp: Filters by timestamp.
        :param Status7 status: Filters by status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select30 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort36 sort: Sorts by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `bakerFee`.
        :param Offset34 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Quote41 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[SetDepositsLimitOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sender', 'level', 'timestamp', 'status', 'select', 'sort', 'offset', 'limit', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_set_deposits_limits" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/set_deposits_limits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SetDepositsLimitOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_set_deposits_limits_count(self, **kwargs):  # noqa: E501
        """Get set deposits limits count  # noqa: E501

        Returns the total number of set deposits limit operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limits_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level32 level: Filters by level.
        :param Timestamp32 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_set_deposits_limits_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_set_deposits_limits_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_set_deposits_limits_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get set deposits limits count  # noqa: E501

        Returns the total number of set deposits limit operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_set_deposits_limits_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Level32 level: Filters by level.
        :param Timestamp32 timestamp: Filters by timestamp.
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['level', 'timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_set_deposits_limits_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/set_deposits_limits/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_transaction_by_hash(self, hash, **kwargs):  # noqa: E501
        """Get transaction by hash  # noqa: E501

        Returns transaction operations with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline24 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote34 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_transaction_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_transaction_by_hash_with_http_info(hash, **kwargs)  # noqa: E501
            return data

    def operations_get_transaction_by_hash_with_http_info(self, hash, **kwargs):  # noqa: E501
        """Get transaction by hash  # noqa: E501

        Returns transaction operations with specified hash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash_with_http_info(hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param Micheline24 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote34 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_transaction_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_transaction_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/transactions/{hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_transaction_by_hash_counter(self, hash, counter, **kwargs):  # noqa: E501
        """Get transaction by hash and counter  # noqa: E501

        Returns transaction operations with specified hash and counter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash_counter(hash, counter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param Micheline25 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote35 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_transaction_by_hash_counter_with_http_info(hash, counter, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_transaction_by_hash_counter_with_http_info(hash, counter, **kwargs)  # noqa: E501
            return data

    def operations_get_transaction_by_hash_counter_with_http_info(self, hash, counter, **kwargs):  # noqa: E501
        """Get transaction by hash and counter  # noqa: E501

        Returns transaction operations with specified hash and counter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash_counter_with_http_info(hash, counter, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param Micheline25 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote35 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'counter', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_transaction_by_hash_counter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_transaction_by_hash_counter`")  # noqa: E501
        # verify the required parameter 'counter' is set
        if ('counter' not in params or
                params['counter'] is None):
            raise ValueError("Missing the required parameter `counter` when calling `operations_get_transaction_by_hash_counter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501
        if 'counter' in params:
            path_params['counter'] = params['counter']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/transactions/{hash}/{counter}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_transaction_by_hash_counter_nonce(self, hash, counter, nonce, **kwargs):  # noqa: E501
        """Get transaction by hash, counter and nonce  # noqa: E501

        Returns an internal transaction operation with specified hash, counter and nonce.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash_counter_nonce(hash, counter, nonce, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param int nonce: Operation nonce (internal) (required)
        :param Micheline26 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote36 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_transaction_by_hash_counter_nonce_with_http_info(hash, counter, nonce, **kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_transaction_by_hash_counter_nonce_with_http_info(hash, counter, nonce, **kwargs)  # noqa: E501
            return data

    def operations_get_transaction_by_hash_counter_nonce_with_http_info(self, hash, counter, nonce, **kwargs):  # noqa: E501
        """Get transaction by hash, counter and nonce  # noqa: E501

        Returns an internal transaction operation with specified hash, counter and nonce.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transaction_by_hash_counter_nonce_with_http_info(hash, counter, nonce, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str hash: Operation hash (required)
        :param int counter: Operation counter (required)
        :param int nonce: Operation nonce (internal) (required)
        :param Micheline26 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote36 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['hash', 'counter', 'nonce', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_transaction_by_hash_counter_nonce" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'hash' is set
        if ('hash' not in params or
                params['hash'] is None):
            raise ValueError("Missing the required parameter `hash` when calling `operations_get_transaction_by_hash_counter_nonce`")  # noqa: E501
        # verify the required parameter 'counter' is set
        if ('counter' not in params or
                params['counter'] is None):
            raise ValueError("Missing the required parameter `counter` when calling `operations_get_transaction_by_hash_counter_nonce`")  # noqa: E501
        # verify the required parameter 'nonce' is set
        if ('nonce' not in params or
                params['nonce'] is None):
            raise ValueError("Missing the required parameter `nonce` when calling `operations_get_transaction_by_hash_counter_nonce`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'hash' in params:
            path_params['hash'] = params['hash']  # noqa: E501
        if 'counter' in params:
            path_params['counter'] = params['counter']  # noqa: E501
        if 'nonce' in params:
            path_params['nonce'] = params['nonce']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/transactions/{hash}/{counter}/{nonce}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_transactions(self, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Returns a list of transaction operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transactions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters transactions by any of the specified fields. Example: `anyof.sender.target=tz1...` will return operations where `sender` OR `target` is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account.
        :param Initiator3 initiator: Filters transactions by initiator. Allowed fields for `.eqx` mode: `target`.
        :param Sender4 sender: Filters transactions by sender. Allowed fields for `.eqx` mode: `target`.
        :param Target1 target: Filters transactions by target. Allowed fields for `.eqx` mode: `sender`, `initiator`.
        :param Amount amount: Filters transactions by amount (microtez).
        :param Id1 id: Filters transactions by id.
        :param Level25 level: Filters transactions by level.
        :param Timestamp25 timestamp: Filters transactions by timestamp.
        :param Entrypoint1 entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Parameter1 parameter: Filters transactions by parameter value. Note, this query parameter supports the following format: `?parameter{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?parameter.token_id=...` or `?parameter.sigs.0.ne=...`.
        :param HasInternals1 has_internals: Filters transactions by presence of internal operations.
        :param Status3 status: Filters transactions by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select27 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort33 sort: Sorts transactions by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`, `allocationFee`, `amount`.
        :param Offset31 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline23 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote33 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_transactions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_transactions_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_transactions_with_http_info(self, **kwargs):  # noqa: E501
        """Get transactions  # noqa: E501

        Returns a list of transaction operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transactions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters transactions by any of the specified fields. Example: `anyof.sender.target=tz1...` will return operations where `sender` OR `target` is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account.
        :param Initiator3 initiator: Filters transactions by initiator. Allowed fields for `.eqx` mode: `target`.
        :param Sender4 sender: Filters transactions by sender. Allowed fields for `.eqx` mode: `target`.
        :param Target1 target: Filters transactions by target. Allowed fields for `.eqx` mode: `sender`, `initiator`.
        :param Amount amount: Filters transactions by amount (microtez).
        :param Id1 id: Filters transactions by id.
        :param Level25 level: Filters transactions by level.
        :param Timestamp25 timestamp: Filters transactions by timestamp.
        :param Entrypoint1 entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Parameter1 parameter: Filters transactions by parameter value. Note, this query parameter supports the following format: `?parameter{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?parameter.token_id=...` or `?parameter.sigs.0.ne=...`.
        :param HasInternals1 has_internals: Filters transactions by presence of internal operations.
        :param Status3 status: Filters transactions by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :param Select27 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort33 sort: Sorts transactions by specified field. Supported fields: `id` (default), `level`, `gasUsed`, `storageUsed`, `bakerFee`, `storageFee`, `allocationFee`, `amount`.
        :param Offset31 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline23 micheline: Format of the parameters, storage and diffs: `0` - JSON, `1` - JSON string, `2` - raw micheline, `3` - raw micheline string
        :param Quote33 quote: Comma-separated list of ticker symbols to inject historical prices into response
        :return: list[TransactionOperation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'initiator', 'sender', 'target', 'amount', 'id', 'level', 'timestamp', 'entrypoint', 'parameter', 'has_internals', 'status', 'select', 'sort', 'offset', 'limit', 'micheline', 'quote']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_transactions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'initiator' in params:
            query_params.append(('initiator', params['initiator']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'target' in params:
            query_params.append(('target', params['target']))  # noqa: E501
        if 'amount' in params:
            query_params.append(('amount', params['amount']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'entrypoint' in params:
            query_params.append(('entrypoint', params['entrypoint']))  # noqa: E501
        if 'parameter' in params:
            query_params.append(('parameter', params['parameter']))  # noqa: E501
        if 'has_internals' in params:
            query_params.append(('hasInternals', params['has_internals']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'quote' in params:
            query_params.append(('quote', params['quote']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionOperation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def operations_get_transactions_count(self, **kwargs):  # noqa: E501
        """Get transactions count  # noqa: E501

        Returns the total number of transaction operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transactions_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters transactions by any of the specified fields. Example: `anyof.sender.target=tz1...` will return operations where `sender` OR `target` is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account.
        :param Initiator4 initiator: Filters transactions by initiator. Allowed fields for `.eqx` mode: `target`.
        :param Sender5 sender: Filters transactions by sender. Allowed fields for `.eqx` mode: `target`.
        :param Target2 target: Filters transactions by target. Allowed fields for `.eqx` mode: `sender`, `initiator`.
        :param Level26 level: Filters transactions by level.
        :param Timestamp26 timestamp: Filters transactions by timestamp.
        :param Entrypoint2 entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Status4 status: Filters transactions by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.operations_get_transactions_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.operations_get_transactions_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def operations_get_transactions_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get transactions count  # noqa: E501

        Returns the total number of transaction operations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.operations_get_transactions_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str anyof: Filters transactions by any of the specified fields. Example: `anyof.sender.target=tz1...` will return operations where `sender` OR `target` is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account.
        :param Initiator4 initiator: Filters transactions by initiator. Allowed fields for `.eqx` mode: `target`.
        :param Sender5 sender: Filters transactions by sender. Allowed fields for `.eqx` mode: `target`.
        :param Target2 target: Filters transactions by target. Allowed fields for `.eqx` mode: `sender`, `initiator`.
        :param Level26 level: Filters transactions by level.
        :param Timestamp26 timestamp: Filters transactions by timestamp.
        :param Entrypoint2 entrypoint: Filters transactions by entrypoint called on the target contract.
        :param Status4 status: Filters transactions by operation status (`applied`, `failed`, `backtracked`, `skipped`).
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['anyof', 'initiator', 'sender', 'target', 'level', 'timestamp', 'entrypoint', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method operations_get_transactions_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'anyof' in params:
            query_params.append(('anyof', params['anyof']))  # noqa: E501
        if 'initiator' in params:
            query_params.append(('initiator', params['initiator']))  # noqa: E501
        if 'sender' in params:
            query_params.append(('sender', params['sender']))  # noqa: E501
        if 'target' in params:
            query_params.append(('target', params['target']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'entrypoint' in params:
            query_params.append(('entrypoint', params['entrypoint']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/operations/transactions/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
