# coding: utf-8

"""
    TzKT API

    # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Hangzhounet: `https://api.hangzhounet.tzkt.io/` ([view docs](https://api.hangzhounet.tzkt.io)) - Ithacanet: `https://api.ithacanet.tzkt.io/` ([view docs](https://api.ithacanet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you must mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** or **\"Built with TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---   # noqa: E501

    OpenAPI spec version: v1.8.3
    Contact: hello@baking-bad.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ContractsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def contracts_build_entrypoint_parameters_get(self, address, name, **kwargs):  # noqa: E501
        """Build entrypoint parameters  # noqa: E501

        Returns micheline parameters converted from its JSON representation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_build_entrypoint_parameters_get(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Entrypoint name (required)
        :param str value: Json parameters
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_build_entrypoint_parameters_get_with_http_info(address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_build_entrypoint_parameters_get_with_http_info(address, name, **kwargs)  # noqa: E501
            return data

    def contracts_build_entrypoint_parameters_get_with_http_info(self, address, name, **kwargs):  # noqa: E501
        """Build entrypoint parameters  # noqa: E501

        Returns micheline parameters converted from its JSON representation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_build_entrypoint_parameters_get_with_http_info(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Entrypoint name (required)
        :param str value: Json parameters
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_build_entrypoint_parameters_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_build_entrypoint_parameters_get`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_build_entrypoint_parameters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/entrypoints/{name}/build', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_build_entrypoint_parameters_post(self, body, address, name, **kwargs):  # noqa: E501
        """Build entrypoint parameters  # noqa: E501

        Returns micheline parameters converted from its JSON representation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_build_entrypoint_parameters_post(body, address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object body: Json parameters (required)
        :param str address: Contract address (required)
        :param str name: Entrypoint name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_build_entrypoint_parameters_post_with_http_info(body, address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_build_entrypoint_parameters_post_with_http_info(body, address, name, **kwargs)  # noqa: E501
            return data

    def contracts_build_entrypoint_parameters_post_with_http_info(self, body, address, name, **kwargs):  # noqa: E501
        """Build entrypoint parameters  # noqa: E501

        Returns micheline parameters converted from its JSON representation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_build_entrypoint_parameters_post_with_http_info(body, address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object body: Json parameters (required)
        :param str address: Contract address (required)
        :param str name: Entrypoint name (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'address', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_build_entrypoint_parameters_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `contracts_build_entrypoint_parameters_post`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_build_entrypoint_parameters_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_build_entrypoint_parameters_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/entrypoints/{name}/build', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get(self, **kwargs):  # noqa: E501
        """Get contracts  # noqa: E501

        Returns a list of contract accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Kind2 kind: Contract kind to filter by (`delegator_contract`, `smart_contract`, or `asset`)
        :param Tzips tzips: Filters by tzips (`fa1`, `fa12`, or `fa2`)
        :param Creator1 creator: Filters contracts by creator. Allowed fields for `.eqx` mode: `manager`, `delegate`.
        :param Manager manager: Filters contracts by manager. Allowed fields for `.eqx` mode: `creator`, `delegate`.
        :param Delegate1 delegate: Filters contracts by delegate. Allowed fields for `.eqx` mode: `manager`, `creator`.
        :param Balance5 balance: Filters contracts by balance
        :param LastActivity1 last_activity: Filters contracts by last activity level (where the contract was updated)
        :param TypeHash type_hash: Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts)
        :param CodeHash code_hash: Filters contracts by 32-bit hash of contract code (helpful for searching same contracts)
        :param Select8 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort13 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset11 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def contracts_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get contracts  # noqa: E501

        Returns a list of contract accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Kind2 kind: Contract kind to filter by (`delegator_contract`, `smart_contract`, or `asset`)
        :param Tzips tzips: Filters by tzips (`fa1`, `fa12`, or `fa2`)
        :param Creator1 creator: Filters contracts by creator. Allowed fields for `.eqx` mode: `manager`, `delegate`.
        :param Manager manager: Filters contracts by manager. Allowed fields for `.eqx` mode: `creator`, `delegate`.
        :param Delegate1 delegate: Filters contracts by delegate. Allowed fields for `.eqx` mode: `manager`, `creator`.
        :param Balance5 balance: Filters contracts by balance
        :param LastActivity1 last_activity: Filters contracts by last activity level (where the contract was updated)
        :param TypeHash type_hash: Filters contracts by 32-bit hash of contract parameter and storage types (helpful for searching similar contracts)
        :param CodeHash code_hash: Filters contracts by 32-bit hash of contract code (helpful for searching same contracts)
        :param Select8 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort13 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset11 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['kind', 'tzips', 'creator', 'manager', 'delegate', 'balance', 'last_activity', 'type_hash', 'code_hash', 'select', 'sort', 'offset', 'limit', 'include_storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501
        if 'tzips' in params:
            query_params.append(('tzips', params['tzips']))  # noqa: E501
        if 'creator' in params:
            query_params.append(('creator', params['creator']))  # noqa: E501
        if 'manager' in params:
            query_params.append(('manager', params['manager']))  # noqa: E501
        if 'delegate' in params:
            query_params.append(('delegate', params['delegate']))  # noqa: E501
        if 'balance' in params:
            query_params.append(('balance', params['balance']))  # noqa: E501
        if 'last_activity' in params:
            query_params.append(('lastActivity', params['last_activity']))  # noqa: E501
        if 'type_hash' in params:
            query_params.append(('typeHash', params['type_hash']))  # noqa: E501
        if 'code_hash' in params:
            query_params.append(('codeHash', params['code_hash']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'include_storage' in params:
            query_params.append(('includeStorage', params['include_storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Contract]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_big_map_by_name(self, address, name, **kwargs):  # noqa: E501
        """Get bigmap by name  # noqa: E501

        Returns contract bigmap with the specified name or storage path.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_map_by_name(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param Micheline13 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_big_map_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_big_map_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
            return data

    def contracts_get_big_map_by_name_with_http_info(self, address, name, **kwargs):  # noqa: E501
        """Get bigmap by name  # noqa: E501

        Returns contract bigmap with the specified name or storage path.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_map_by_name_with_http_info(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param Micheline13 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_big_map_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_big_map_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_big_map_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_big_map_by_name_keys(self, address, name, **kwargs):  # noqa: E501
        """Get bigmap keys  # noqa: E501

        Returns keys of a contract bigmap with the specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_map_by_name_keys(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key2 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value3 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param LastLevel2 last_level: Filters bigmap keys by the last update level.
        :param Select12 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort17 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`.
        :param Offset15 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline14 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_big_map_by_name_keys_with_http_info(address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_big_map_by_name_keys_with_http_info(address, name, **kwargs)  # noqa: E501
            return data

    def contracts_get_big_map_by_name_keys_with_http_info(self, address, name, **kwargs):  # noqa: E501
        """Get bigmap keys  # noqa: E501

        Returns keys of a contract bigmap with the specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_map_by_name_keys_with_http_info(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key2 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value3 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param LastLevel2 last_level: Filters bigmap keys by the last update level.
        :param Select12 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort17 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`.
        :param Offset15 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline14 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'active', 'key', 'value', 'last_level', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_big_map_by_name_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_big_map_by_name_keys`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_big_map_by_name_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'last_level' in params:
            query_params.append(('lastLevel', params['last_level']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKey]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_big_maps(self, address, **kwargs):  # noqa: E501
        """Get contract bigmaps  # noqa: E501

        Returns all active bigmaps allocated in the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_maps(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param Tags2 tags: Filters bigmaps tags (`metadata`, `token_metadata`, `ledger`).
        :param Select11 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object.             If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort16 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset14 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline12 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_big_maps_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_big_maps_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_big_maps_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract bigmaps  # noqa: E501

        Returns all active bigmaps allocated in the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_big_maps_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param Tags2 tags: Filters bigmaps tags (`metadata`, `token_metadata`, `ledger`).
        :param Select11 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object.             If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort16 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset14 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline12 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'tags', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_big_maps" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_big_maps`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMap]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_by_address(self, address, **kwargs):  # noqa: E501
        """Get contract by address  # noqa: E501

        Returns a contract account with the specified address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_by_address(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_by_address_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_by_address_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_by_address_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract by address  # noqa: E501

        Returns a contract account with the specified address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_by_address_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :return: Contract
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_by_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_by_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contract',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_code(self, address, **kwargs):  # noqa: E501
        """Get contract code  # noqa: E501

        Returns a code of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_code(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param int level: Level at which contract code should be taken. If `0` or not specified, the current value will be returned.
        :param int format: Code format (`0` - micheline, `1` - michelson, `2` - bytes (base64))
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_code_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_code_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_code_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract code  # noqa: E501

        Returns a code of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_code_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param int level: Level at which contract code should be taken. If `0` or not specified, the current value will be returned.
        :param int format: Code format (`0` - micheline, `1` - michelson, `2` - bytes (base64))
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/code', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_contract_view_by_name(self, address, name, **kwargs):  # noqa: E501
        """Get view by name  # noqa: E501

        Returns contract view with specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_contract_view_by_name(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param str name: View name (required)
        :param bool json: Include parameter and return types in human-readable JSON format
        :param bool micheline: Include parameter and return types in micheline format
        :param bool michelson: Include parameter and return types in michelson format
        :return: ContractView
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_contract_view_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_contract_view_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
            return data

    def contracts_get_contract_view_by_name_with_http_info(self, address, name, **kwargs):  # noqa: E501
        """Get view by name  # noqa: E501

        Returns contract view with specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_contract_view_by_name_with_http_info(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param str name: View name (required)
        :param bool json: Include parameter and return types in human-readable JSON format
        :param bool micheline: Include parameter and return types in micheline format
        :param bool michelson: Include parameter and return types in michelson format
        :return: ContractView
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'json', 'micheline', 'michelson']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_contract_view_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_contract_view_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_contract_view_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'json' in params:
            query_params.append(('json', params['json']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'michelson' in params:
            query_params.append(('michelson', params['michelson']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/views/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContractView',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_contract_views(self, address, **kwargs):  # noqa: E501
        """Get contract views  # noqa: E501

        Returns all views of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_contract_views(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param bool json: Include parameter and return types in human-readable JSON format
        :param bool micheline: Include parameter and return types in micheline format
        :param bool michelson: Include parameter and return types in michelson format
        :return: list[ContractView]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_contract_views_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_contract_views_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_contract_views_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract views  # noqa: E501

        Returns all views of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_contract_views_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param bool json: Include parameter and return types in human-readable JSON format
        :param bool micheline: Include parameter and return types in micheline format
        :param bool michelson: Include parameter and return types in michelson format
        :return: list[ContractView]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'json', 'micheline', 'michelson']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_contract_views" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_contract_views`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'json' in params:
            query_params.append(('json', params['json']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'michelson' in params:
            query_params.append(('michelson', params['michelson']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/views', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContractView]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_count(self, **kwargs):  # noqa: E501
        """Get contracts count  # noqa: E501

        Returns a number of contract accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Kind3 kind: Contract kind to filter by (`delegator_contract` or `smart_contract`)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def contracts_get_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get contracts count  # noqa: E501

        Returns a number of contract accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Kind3 kind: Contract kind to filter by (`delegator_contract` or `smart_contract`)
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['kind']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'kind' in params:
            query_params.append(('kind', params['kind']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_entrypoint_by_name(self, address, name, **kwargs):  # noqa: E501
        """Get entrypoint by name  # noqa: E501

        Returns contract's entrypoint with specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_entrypoint_by_name(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param str name: Entrypoint name (required)
        :param bool json: Include parameters schema in human-readable JSON format
        :param bool micheline: Include parameters schema in micheline format
        :param bool michelson: Include parameters schema in michelson format
        :return: Entrypoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_entrypoint_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_entrypoint_by_name_with_http_info(address, name, **kwargs)  # noqa: E501
            return data

    def contracts_get_entrypoint_by_name_with_http_info(self, address, name, **kwargs):  # noqa: E501
        """Get entrypoint by name  # noqa: E501

        Returns contract's entrypoint with specified name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_entrypoint_by_name_with_http_info(address, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param str name: Entrypoint name (required)
        :param bool json: Include parameters schema in human-readable JSON format
        :param bool micheline: Include parameters schema in micheline format
        :param bool michelson: Include parameters schema in michelson format
        :return: Entrypoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'json', 'micheline', 'michelson']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_entrypoint_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_entrypoint_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_entrypoint_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'json' in params:
            query_params.append(('json', params['json']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'michelson' in params:
            query_params.append(('michelson', params['michelson']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/entrypoints/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Entrypoint',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_entrypoints(self, address, **kwargs):  # noqa: E501
        """Get contract entrypoints  # noqa: E501

        Returns entrypoints of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_entrypoints(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param bool all: If true, returns all entrypoints, including unused ones.             Unused means that the entrypoint can be normalized to a more specific one.             For example here `(or %entry1 (unit %entry2) (nat %entry3))` the `%entry1` is unused entrypoint             because it can be normalized to `%entry2` or `%entry3`
        :param bool json: Include parameters schema in human-readable JSON format
        :param bool micheline: Include parameters schema in micheline format
        :param bool michelson: Include parameters schema in michelson format
        :return: list[Entrypoint]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_entrypoints_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_entrypoints_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_entrypoints_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract entrypoints  # noqa: E501

        Returns entrypoints of the specified contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_entrypoints_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param bool all: If true, returns all entrypoints, including unused ones.             Unused means that the entrypoint can be normalized to a more specific one.             For example here `(or %entry1 (unit %entry2) (nat %entry3))` the `%entry1` is unused entrypoint             because it can be normalized to `%entry2` or `%entry3`
        :param bool json: Include parameters schema in human-readable JSON format
        :param bool micheline: Include parameters schema in micheline format
        :param bool michelson: Include parameters schema in michelson format
        :return: list[Entrypoint]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'all', 'json', 'micheline', 'michelson']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_entrypoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_entrypoints`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501
        if 'json' in params:
            query_params.append(('json', params['json']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501
        if 'michelson' in params:
            query_params.append(('michelson', params['michelson']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/entrypoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Entrypoint]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_historical_keys(self, address, name, level, **kwargs):  # noqa: E501
        """Get historical keys  # noqa: E501

        Returns a list of bigmap keys at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_historical_keys(address, name, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param int level: Level of the block at which you want to get bigmap keys (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key3 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value4 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Select13 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort19 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default).
        :param Offset17 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline17 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyHistorical]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_historical_keys_with_http_info(address, name, level, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_historical_keys_with_http_info(address, name, level, **kwargs)  # noqa: E501
            return data

    def contracts_get_historical_keys_with_http_info(self, address, name, level, **kwargs):  # noqa: E501
        """Get historical keys  # noqa: E501

        Returns a list of bigmap keys at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_historical_keys_with_http_info(address, name, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param int level: Level of the block at which you want to get bigmap keys (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key3 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value4 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Select13 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort19 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default).
        :param Offset17 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline17 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyHistorical]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'level', 'active', 'key', 'value', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_historical_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_historical_keys`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_historical_keys`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `contracts_get_historical_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'level' in params:
            path_params['level'] = params['level']  # noqa: E501

        query_params = []
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}/historical_keys/{level}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKeyHistorical]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_interface(self, address, **kwargs):  # noqa: E501
        """Get JSON Schema [2020-12] interface for the contract  # noqa: E501

        Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_interface(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :return: ContractInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_interface_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_interface_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_interface_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get JSON Schema [2020-12] interface for the contract  # noqa: E501

        Returns standard JSON Schema for contract storage, entrypoints, and Big_map entries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_interface_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :return: ContractInterface
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContractInterface',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_key(self, address, name, key, **kwargs):  # noqa: E501
        """Get bigmap key  # noqa: E501

        Returns the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key(address, name, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline15 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_key_with_http_info(address, name, key, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_key_with_http_info(address, name, key, **kwargs)  # noqa: E501
            return data

    def contracts_get_key_with_http_info(self, address, name, key, **kwargs):  # noqa: E501
        """Get bigmap key  # noqa: E501

        Returns the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key_with_http_info(address, name, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline15 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'key', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_key`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `contracts_get_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}/keys/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMapKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_key2(self, address, name, level, key, **kwargs):  # noqa: E501
        """Get historical key  # noqa: E501

        Returns the specified bigmap key at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key2(address, name, level, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param int level: Level of the block at which you want to get bigmap key (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline18 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKeyHistorical
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_key2_with_http_info(address, name, level, key, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_key2_with_http_info(address, name, level, key, **kwargs)  # noqa: E501
            return data

    def contracts_get_key2_with_http_info(self, address, name, level, key, **kwargs):  # noqa: E501
        """Get historical key  # noqa: E501

        Returns the specified bigmap key at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key2_with_http_info(address, name, level, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param int level: Level of the block at which you want to get bigmap key (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline18 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKeyHistorical
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'level', 'key', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_key2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_key2`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_key2`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `contracts_get_key2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `contracts_get_key2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'level' in params:
            path_params['level'] = params['level']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}/historical_keys/{level}/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMapKeyHistorical',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_key_updates(self, address, name, key, **kwargs):  # noqa: E501
        """Get bigmap key updates  # noqa: E501

        Returns updates history for the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key_updates(address, name, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Sort18 sort: Sorts bigmap updates by specified field. Supported fields: `id` (default).
        :param Offset16 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline16 micheline: Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_key_updates_with_http_info(address, name, key, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_key_updates_with_http_info(address, name, key, **kwargs)  # noqa: E501
            return data

    def contracts_get_key_updates_with_http_info(self, address, name, key, **kwargs):  # noqa: E501
        """Get bigmap key updates  # noqa: E501

        Returns updates history for the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_key_updates_with_http_info(address, name, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param str name: Bigmap name is the last piece of the bigmap storage path.             For example, if the storage path is `ledger` or `assets.ledger`, then the name is `ledger`.             If there are multiple bigmaps with the same name, for example `assets.ledger` and `tokens.ledger`, you can specify the full path. (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Sort18 sort: Sorts bigmap updates by specified field. Supported fields: `id` (default).
        :param Offset16 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline16 micheline: Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'name', 'key', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_key_updates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_key_updates`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `contracts_get_key_updates`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `contracts_get_key_updates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/bigmaps/{name}/keys/{key}/updates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKeyUpdate]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_raw_storage(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage  # noqa: E501

        Returns raw contract storage value in micheline format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage value should be taken. If `0` or not specified, the current value will be returned.
        :return: IMicheline
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_raw_storage_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_raw_storage_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_raw_storage_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage  # noqa: E501

        Returns raw contract storage value in micheline format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage value should be taken. If `0` or not specified, the current value will be returned.
        :return: IMicheline
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_raw_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_raw_storage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IMicheline',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_raw_storage_history(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage history  # noqa: E501

        Returns raw contract storage historical values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage_history(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int last_id: Id of the last item received (for pagination)
        :param int limit: Maximum number of items to return
        :return: list[StorageRecord]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_raw_storage_history_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_raw_storage_history_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_raw_storage_history_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage history  # noqa: E501

        Returns raw contract storage historical values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage_history_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int last_id: Id of the last item received (for pagination)
        :param int limit: Maximum number of items to return
        :return: list[StorageRecord]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'last_id', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_raw_storage_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_raw_storage_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage/raw/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorageRecord]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_raw_storage_schema(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage schema  # noqa: E501

        Returns micheline schema (type) of the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage_schema(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned.
        :return: IMicheline
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_raw_storage_schema_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_raw_storage_schema_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_raw_storage_schema_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get raw contract storage schema  # noqa: E501

        Returns micheline schema (type) of the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_raw_storage_schema_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned.
        :return: IMicheline
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_raw_storage_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_raw_storage_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage/raw/schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IMicheline',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_same(self, address, **kwargs):  # noqa: E501
        """Get same contracts  # noqa: E501

        Returns contracts which have the same script as the specified one. Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_same(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param Select9 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort14 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset12 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_same_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_same_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_same_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get same contracts  # noqa: E501

        Returns contracts which have the same script as the specified one. Note, contract scripts are compared by 32-bit hash, so in very rare cases there may be collisions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_same_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param Select9 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort14 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset12 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'select', 'sort', 'offset', 'limit', 'include_storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_same" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_same`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'include_storage' in params:
            query_params.append(('includeStorage', params['include_storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/same', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Contract]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_similar(self, address, **kwargs):  # noqa: E501
        """Get similar contracts  # noqa: E501

        Returns contracts which have the same interface (parameter and storage types) as the specified one. Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_similar(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param Select10 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort15 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset13 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_similar_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_similar_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_similar_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get similar contracts  # noqa: E501

        Returns contracts which have the same interface (parameter and storage types) as the specified one. Note, contract parameter and storage types are compared by 32-bit hash, so in very rare cases there may be collisions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_similar_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (starting with KT) (required)
        :param Select10 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort15 sort: Sorts contracts by specified field. Supported fields: `id` (default), `balance`, `firstActivity`, `lastActivity`, `numTransactions`.
        :param Offset13 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param bool include_storage: Specifies whether to include contract storage value in response.
        :return: list[Contract]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'select', 'sort', 'offset', 'limit', 'include_storage']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_similar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_similar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'include_storage' in params:
            query_params.append(('includeStorage', params['include_storage']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/similar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Contract]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_storage(self, address, **kwargs):  # noqa: E501
        """Get contract storage  # noqa: E501

        Returns contract storage value in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage value should be taken. If `0` or not specified, the current value will be returned.
        :param str path: Path in the JSON value (point-separated list of field names, e.g. `path=settings.refund_time` to return
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_storage_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_storage_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_storage_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract storage  # noqa: E501

        Returns contract storage value in JSON format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage value should be taken. If `0` or not specified, the current value will be returned.
        :param str path: Path in the JSON value (point-separated list of field names, e.g. `path=settings.refund_time` to return
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level', 'path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_storage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_storage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_storage_history(self, address, **kwargs):  # noqa: E501
        """Get contract storage history  # noqa: E501

        Returns contract storage historical values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage_history(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int last_id: Id of the last item received (for pagination)
        :param int limit: Maximum number of items to return
        :return: list[StorageRecord]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_storage_history_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_storage_history_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_storage_history_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract storage history  # noqa: E501

        Returns contract storage historical values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage_history_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int last_id: Id of the last item received (for pagination)
        :param int limit: Maximum number of items to return
        :return: list[StorageRecord]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'last_id', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_storage_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_storage_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StorageRecord]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def contracts_get_storage_schema(self, address, **kwargs):  # noqa: E501
        """Get contract storage schema  # noqa: E501

        Returns JSON schema of the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage_schema(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.contracts_get_storage_schema_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.contracts_get_storage_schema_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def contracts_get_storage_schema_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get contract storage schema  # noqa: E501

        Returns JSON schema of the contract storage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.contracts_get_storage_schema_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str address: Contract address (required)
        :param int level: Level at which storage schema should be taken. If `0` or not specified, the current schema will be returned.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method contracts_get_storage_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `contracts_get_storage_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/contracts/{address}/storage/schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
