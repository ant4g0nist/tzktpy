# coding: utf-8

"""
    TzKT API

    # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Hangzhounet: `https://api.hangzhounet.tzkt.io/` ([view docs](https://api.hangzhounet.tzkt.io)) - Ithacanet: `https://api.ithacanet.tzkt.io/` ([view docs](https://api.ithacanet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@baking-bad.org  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you must mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** or **\"Built with TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---   # noqa: E501

    OpenAPI spec version: v1.8.3
    Contact: hello@baking-bad.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class BigMapsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def big_maps_get_big_map_by_id(self, id, **kwargs):  # noqa: E501
        """Get bigmap by Id  # noqa: E501

        Returns a bigmap with the specified Id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param Micheline3 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: BigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_big_map_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_big_map_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def big_maps_get_big_map_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get bigmap by Id  # noqa: E501

        Returns a bigmap with the specified Id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param Micheline3 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: BigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_big_map_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_big_map_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_big_map_type(self, id, **kwargs):  # noqa: E501
        """Get bigmap type  # noqa: E501

        Returns a type of the bigmap with the specified Id in Micheline format (with annotations).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :return: MichelinePrim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_big_map_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_big_map_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def big_maps_get_big_map_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get bigmap type  # noqa: E501

        Returns a type of the bigmap with the specified Id in Micheline format (with annotations).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :return: MichelinePrim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_big_map_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_big_map_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/type', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MichelinePrim',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_big_map_updates(self, **kwargs):  # noqa: E501
        """Get bigmap updates  # noqa: E501

        Returns a list of all bigmap updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_updates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Bigmap bigmap: Filters updates by bigmap ptr
        :param Path1 path: Filters updates by bigmap path
        :param Contract1 contract: Filters updates by bigmap contract
        :param Tags1 tags: Filters updates by bigmap tags: `metadata`, `token_metadata`, `ledger`
        :param Action action: Filters updates by action
        :param Value value: Filters updates by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Level1 level: Filters updates by level
        :param Timestamp1 timestamp: Filters updates by timestamp.
        :param Sort6 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `ptr`, `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset4 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline2 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: list[BigMapUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_big_map_updates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_big_map_updates_with_http_info(**kwargs)  # noqa: E501
            return data

    def big_maps_get_big_map_updates_with_http_info(self, **kwargs):  # noqa: E501
        """Get bigmap updates  # noqa: E501

        Returns a list of all bigmap updates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_map_updates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Bigmap bigmap: Filters updates by bigmap ptr
        :param Path1 path: Filters updates by bigmap path
        :param Contract1 contract: Filters updates by bigmap contract
        :param Tags1 tags: Filters updates by bigmap tags: `metadata`, `token_metadata`, `ledger`
        :param Action action: Filters updates by action
        :param Value value: Filters updates by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Level1 level: Filters updates by level
        :param Timestamp1 timestamp: Filters updates by timestamp.
        :param Sort6 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `ptr`, `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset4 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline2 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: list[BigMapUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bigmap', 'path', 'contract', 'tags', 'action', 'value', 'level', 'timestamp', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_big_map_updates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bigmap' in params:
            query_params.append(('bigmap', params['bigmap']))  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'contract' in params:
            query_params.append(('contract', params['contract']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/updates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapUpdate]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_big_maps(self, **kwargs):  # noqa: E501
        """Get bigmaps  # noqa: E501

        Returns a list of bigmaps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_maps(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Contract contract: Filters bigmaps by smart contract address.
        :param Path path: Filters bigmaps by path in the contract storage.
        :param Tags tags: Filters bigmaps by tags: `metadata`, `token_metadata`, `ledger`.
        :param bool active: Filters bigmaps by status: `true` - active, `false` - removed.
        :param LastLevel last_level: Filters bigmaps by the last update level.
        :param Select2 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort5 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `ptr`, `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset3 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline1 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: list[BigMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_big_maps_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_big_maps_with_http_info(**kwargs)  # noqa: E501
            return data

    def big_maps_get_big_maps_with_http_info(self, **kwargs):  # noqa: E501
        """Get bigmaps  # noqa: E501

        Returns a list of bigmaps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_maps_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Contract contract: Filters bigmaps by smart contract address.
        :param Path path: Filters bigmaps by path in the contract storage.
        :param Tags tags: Filters bigmaps by tags: `metadata`, `token_metadata`, `ledger`.
        :param bool active: Filters bigmaps by status: `true` - active, `false` - removed.
        :param LastLevel last_level: Filters bigmaps by the last update level.
        :param Select2 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort5 sort: Sorts bigmaps by specified field. Supported fields: `id` (default), `ptr`, `firstLevel`, `lastLevel`, `totalKeys`, `activeKeys`, `updates`.
        :param Offset3 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline1 micheline: Format of the bigmap key and value type: `0` - JSON, `2` - Micheline
        :return: list[BigMap]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contract', 'path', 'tags', 'active', 'last_level', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_big_maps" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contract' in params:
            query_params.append(('contract', params['contract']))  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'last_level' in params:
            query_params.append(('lastLevel', params['last_level']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMap]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_big_maps_count(self, **kwargs):  # noqa: E501
        """Get bigmaps count  # noqa: E501

        Returns the total number of bigmaps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_maps_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_big_maps_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_big_maps_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def big_maps_get_big_maps_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get bigmaps count  # noqa: E501

        Returns the total number of bigmaps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_big_maps_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_big_maps_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_historical_keys(self, id, level, **kwargs):  # noqa: E501
        """Get historical keys  # noqa: E501

        Returns a list of bigmap keys at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_historical_keys(id, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param int level: Level of the block at which you want to get bigmap keys (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key1 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value2 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Select4 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort9 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default).
        :param Offset7 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline7 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyHistorical]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_historical_keys_with_http_info(id, level, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_historical_keys_with_http_info(id, level, **kwargs)  # noqa: E501
            return data

    def big_maps_get_historical_keys_with_http_info(self, id, level, **kwargs):  # noqa: E501
        """Get historical keys  # noqa: E501

        Returns a list of bigmap keys at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_historical_keys_with_http_info(id, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param int level: Level of the block at which you want to get bigmap keys (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key1 key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value2 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param Select4 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort9 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default).
        :param Offset7 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline7 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyHistorical]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'level', 'active', 'key', 'value', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_historical_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_historical_keys`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `big_maps_get_historical_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'level' in params:
            path_params['level'] = params['level']  # noqa: E501

        query_params = []
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/historical_keys/{level}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKeyHistorical]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_key(self, id, key, **kwargs):  # noqa: E501
        """Get bigmap key  # noqa: E501

        Returns the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key(id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline5 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_key_with_http_info(id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_key_with_http_info(id, key, **kwargs)  # noqa: E501
            return data

    def big_maps_get_key_with_http_info(self, id, key, **kwargs):  # noqa: E501
        """Get bigmap key  # noqa: E501

        Returns the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key_with_http_info(id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline5 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKey
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'key', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `big_maps_get_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/keys/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMapKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_key2(self, id, level, key, **kwargs):  # noqa: E501
        """Get historical key  # noqa: E501

        Returns the specified bigmap key at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key2(id, level, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param int level: Level of the block at which you want to get bigmap key (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline8 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKeyHistorical
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_key2_with_http_info(id, level, key, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_key2_with_http_info(id, level, key, **kwargs)  # noqa: E501
            return data

    def big_maps_get_key2_with_http_info(self, id, level, key, **kwargs):  # noqa: E501
        """Get historical key  # noqa: E501

        Returns the specified bigmap key at the specific block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key2_with_http_info(id, level, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param int level: Level of the block at which you want to get bigmap key (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Micheline8 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: BigMapKeyHistorical
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'level', 'key', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_key2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_key2`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in params or
                params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `big_maps_get_key2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `big_maps_get_key2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'level' in params:
            path_params['level'] = params['level']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/historical_keys/{level}/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BigMapKeyHistorical',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_key_updates(self, id, key, **kwargs):  # noqa: E501
        """Get bigmap key updates  # noqa: E501

        Returns updates history for the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key_updates(id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Sort8 sort: Sorts bigmap updates by specified field. Supported fields: `id` (default).
        :param Offset6 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline6 micheline: Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_key_updates_with_http_info(id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_key_updates_with_http_info(id, key, **kwargs)  # noqa: E501
            return data

    def big_maps_get_key_updates_with_http_info(self, id, key, **kwargs):  # noqa: E501
        """Get bigmap key updates  # noqa: E501

        Returns updates history for the specified bigmap key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_key_updates_with_http_info(id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param str key: Either a key hash (`expr123...`) or a plain value (`abcde...`).             Even if the key is complex (an object or an array), you can specify it as is, for example, `/keys/{\"address\":\"tz123\",\"nat\":\"123\"}`. (required)
        :param Sort8 sort: Sorts bigmap updates by specified field. Supported fields: `id` (default).
        :param Offset6 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline6 micheline: Format of the key value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKeyUpdate]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'key', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_key_updates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_key_updates`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `big_maps_get_key_updates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/keys/{key}/updates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKeyUpdate]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def big_maps_get_keys(self, id, **kwargs):  # noqa: E501
        """Get bigmap keys  # noqa: E501

        Returns a list of bigmap keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_keys(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value1 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param LastLevel1 last_level: Filters bigmap keys by the last update level.
        :param Select3 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort7 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`.
        :param Offset5 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline4 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.big_maps_get_keys_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.big_maps_get_keys_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def big_maps_get_keys_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get bigmap keys  # noqa: E501

        Returns a list of bigmap keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.big_maps_get_keys_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Bigmap Id (required)
        :param bool active: Filters keys by status: `true` - active, `false` - removed.
        :param Key key: Filters keys by JSON key. Note, this query parameter supports the following format: `?key{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?key.token_id=...`.
        :param Value1 value: Filters keys by JSON value. Note, this query parameter supports the following format: `?value{.path?}{.mode?}=...`,             so you can specify a path to a particular field to filter by, for example: `?value.balance.gt=...`.
        :param LastLevel1 last_level: Filters bigmap keys by the last update level.
        :param Select3 select: Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both `.fields` and `.values` modes.
        :param Sort7 sort: Sorts bigmap keys by specified field. Supported fields: `id` (default), `firstLevel`, `lastLevel`, `updates`.
        :param Offset5 offset: Specifies which or how many items should be skipped
        :param int limit: Maximum number of items to return
        :param Micheline4 micheline: Format of the bigmap key and value: `0` - JSON, `1` - JSON string, `2` - Micheline, `3` - Micheline string
        :return: list[BigMapKey]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'active', 'key', 'value', 'last_level', 'select', 'sort', 'offset', 'limit', 'micheline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method big_maps_get_keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `big_maps_get_keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'active' in params:
            query_params.append(('active', params['active']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'last_level' in params:
            query_params.append(('lastLevel', params['last_level']))  # noqa: E501
        if 'select' in params:
            query_params.append(('select', params['select']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'micheline' in params:
            query_params.append(('micheline', params['micheline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/bigmaps/{id}/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BigMapKey]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
